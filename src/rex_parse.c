/* Copyright 2020-2024 Kinglet B.V.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <ctype.h>

struct rex_nfa; 
#include "rex_parse.h"
#include "rex.h"
#include "rex_set_range.h"
#include "uc_cat_ranges.h"

static uint32_t hex_to_int(const char *txt, size_t len) {
  size_t digit;
  uint32_t val = 0;
  for (digit = 0; digit < len; ++digit) {
    if ((txt[digit] >= '0') && (txt[digit] <= '9')) {
      val = (val << 4) + (txt[digit] - '0');
    }
    else if ((txt[digit] >= 'a') && (txt[digit] <= 'f')) {
      val = (val << 4) + (txt[digit] - 'a' + 0xA);
    }
    else {
      val = (val << 4) + (txt[digit] - 'A' + 0xA);
    }
  }
  return val;
}
static uint32_t oct_to_int(const char *txt, size_t len) {
  size_t digit;
  uint32_t val = 0;
  for (digit = 0; digit < len; ++digit) {
    val = (val << 3) + (txt[digit] - '0');
  }
  return val;
}
/* --------- START OF GENERATED CODE ------------ */
#include <stdlib.h> /* realloc(), free(), NULL, size_t */
#include <string.h> /* memcpy() */
#include <stddef.h> /* size_t */
#include <stdint.h> /* SIZE_MAX */
struct rex_sym_data {
  int state_;
  union {
    struct { size_t initial_ ; size_t final_ ; } uv0_;
    uint32_t uv1_;
    struct { int is_inverted_ ; size_t first_ ; size_t last_ ; } uv2_;
    struct rex_set_range uv3_;
  } v_;
};
static const int rex_scan_table_grouped_rex_[] = {
  /*
   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C */
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  2,  0,  3,  4,  4,  5,  6,  7,  8,  9, 10, 11, 12,  4,  4, 13, 14, 15,  4,  4,  4,  4,  4, 16, 17, 18, 19,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 20, 21, 22,  1,  1,  1,  1,
    0,  2,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  2,  2,  2,
    0,  2,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  3,  3,  3,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  4,  4,  4,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  5,  5,  5,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  6,  6,  6,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  7,  7,  7,  7,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  8,  8,  8,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  9,  9,  9,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10, 10, 10, 10,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 11, 11, 11, 11,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 12, 12, 12, 12,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 13, 13, 13, 13,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 14, 14, 14, 14,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 15, 15, 15, 15,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 16, 16, 16, 16,
    0,  0,  0, 23,  0, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24,  0, 23, 23, 23, 25,  0,  0, 26, 27, 23, 23, 23, 23, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 23, 23, 23, 17, 17, 17, 17,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 18, 18, 18, 18,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 19, 19, 19, 19,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 20, 20, 20, 20,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 21, 21, 21, 21,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 22, 22, 22, 22,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 23, 23, 23, 23,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 38,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 24, 24, 24, 24,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 25, 25, 25, 25,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 39,  0,  0, 26, 26, 26, 26,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 27, 27, 27, 27,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 28, 28, 28, 28,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 29, 29, 29, 29,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 30, 30, 30, 30,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 31, 31, 31, 31,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 40,  0,  0, 32, 32, 32, 32,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 33, 33, 33, 33,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 34, 34, 34, 34,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41, 41,  0,  0,  0, 41, 41,  0,  0,  0,  0,  0,  0,  0, 41, 41, 41,  0,  0,  0,  0,  0,  0,  0, 42,  0,  0, 35, 35, 35, 35,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 36, 36, 36, 36,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43, 43,  0,  0,  0, 43, 43,  0,  0,  0,  0,  0,  0,  0, 43, 43, 43,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 37, 37, 37, 37,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 44,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 38, 38, 38, 38,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 45, 45, 45, 45, 45,  0,  0,  0,  0, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,  0,  0,  0, 39, 39, 39, 39,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 46, 46, 46, 46, 46,  0,  0,  0,  0, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,  0,  0,  0, 40, 40, 40, 40,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 47, 47,  0,  0,  0, 47, 47,  0,  0,  0,  0,  0,  0,  0, 47, 47, 47,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41, 41, 41, 41,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 48, 48,  0,  0,  0, 48, 48,  0,  0,  0,  0,  0,  0,  0, 48, 48, 48,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 42, 42, 42, 42,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 49, 49,  0,  0,  0, 49, 49,  0,  0,  0,  0,  0,  0,  0, 49, 49, 49,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 43, 43, 43, 43,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 44, 44, 44, 44,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 50, 50,  0,  0,  0, 50, 50, 50, 50, 50,  0,  0,  0,  0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,  0,  0, 51, 45, 45, 45, 45,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 52, 52,  0,  0,  0, 52, 52, 52, 52, 52,  0,  0,  0,  0, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,  0,  0, 53, 46, 46, 46, 46,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 54, 54,  0,  0,  0, 54, 54,  0,  0,  0,  0,  0,  0,  0, 54, 54, 54,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 47, 47, 47, 47,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 48, 48,  0,  0,  0, 48, 48,  0,  0,  0,  0,  0,  0,  0, 48, 48, 48,  0,  0,  0,  0,  0,  0,  0,  0,  0, 55, 48, 48, 48, 48,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 49, 49, 49, 49,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 50, 50,  0,  0,  0, 50, 50, 50, 50, 50,  0,  0,  0,  0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,  0,  0, 51, 50, 50, 50, 50,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 51, 51, 51, 51,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 52, 52,  0,  0,  0, 52, 52, 52, 52, 52,  0,  0,  0,  0, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,  0,  0, 53, 52, 52, 52, 52,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 53, 53, 53, 53,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 56, 56,  0,  0,  0, 56, 56,  0,  0,  0,  0,  0,  0,  0, 56, 56, 56,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 54, 54, 54, 54,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 55, 55, 55, 55,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 56, 56, 56, 56
};
static const size_t rex_num_scan_table_rows_ = 57;
static const size_t rex_num_scan_table_grouped_columns_ = 45;
static const int rex_scan_table_grouped_raw_encoding_[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 4, 5, 4, 6, 4, 4, 5, 7, 8, 9, 10, 11, 12, 13, 4, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 16, 17, 4, 4, 4, 18, 4, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 21, 21, 21, 21, 21, 21, 21, 21, 21, 23, 24, 25, 26, 27, 21, 4, 28, 29, 20, 20, 20, 30, 21, 21, 21, 21, 21, 21, 21, 31, 21, 32, 21, 33, 21, 34, 35, 36, 21, 37, 21, 21, 38, 39, 40, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
static const int rex_utf8_decoder_[] = {
  /*
   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  10  11  12  13  14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  28  29  2A  2B  2C  2D  2E  2F  30  31  32  33  34  35  36  37  38  39  3A  3B  3C  3D  3E  3F  40  41  42  43  44  45  46  47  48  49  4A  4B  4C  4D  4E  4F  50  51  52  53  54  55  56  57  58  59  5A  5B  5C  5D  5E  5F  60  61  62  63  64  65  66  67  68  69  6A  6B  6C  6D  6E  6F  70  71  72  73  74  75  76  77  78  79  7A  7B  7C  7D  7E  7F  80  81  82  83  84  85  86  87  88  89  8A  8B  8C  8D  8E  8F  90  91  92  93  94  95  96  97  98  99  9A  9B  9C  9D  9E  9F  A0  A1  A2  A3  A4  A5  A6  A7  A8  A9  AA  AB  AC  AD  AE  AF  B0  B1  B2  B3  B4  B5  B6  B7  B8  B9  BA  BB  BC  BD  BE  BF  C0  C1  C2  C3  C4  C5  C6  C7  C8  C9  CA  CB  CC  CD  CE  CF  D0  D1  D2  D3  D4  D5  D6  D7  D8  D9  DA  DB  DC  DD  DE  DF  E0  E1  E2  E3  E4  E5  E6  E7  E8  E9  EA  EB  EC  ED  EE  EF  F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  FA  FB  FC  FD  FE  FF */
    0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  4,  5,  4,  6,  4,  4,  5,  7,  8,  9, 10, 11, 12, 13,  4, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 16, 17,  4,  4,  4, 18,  4, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 21, 21, 21, 21, 21, 21, 21, 21, 21, 23, 24, 25, 26, 27, 21,  4, 28, 29, 20, 20, 20, 30, 21, 21, 21, 21, 21, 21, 21, 31, 21, 32, 21, 33, 21, 34, 35, 36, 21, 37, 21, 21, 38, 39, 40,  4,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -4, -5, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -6, -7, -8, -9, -9, -9,-10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-11,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-12,-13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-14,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-15,-16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-17,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-18,-19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};
static const size_t rex_scan_table_rex[] = {
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 4, 4, 5, 4, 4, 4, 6, 7, 8, 9,10,11,12, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,13,14, 4, 4, 4,15, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,16,17,18,19, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,20,21,22, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 9, 9,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,10,10,10,10,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,11,11,11,11,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,12,12,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,13,13,13,13,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,14,14,14,14,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,15,15,15,15,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,16,16,16,16,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23, 0,23, 0,23, 0, 0,23,23,23,23,23,23,23,23, 0,24,24,24,24,24,24,24,24, 0, 0,23,23, 0, 0, 0,23, 0,25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,26, 0, 0, 0, 0, 0, 0, 0, 0, 0,27,23,23,23,23, 0, 0,28,29, 0, 0, 0,30, 0, 0, 0, 0, 0, 0, 0,31, 0,32, 0,33, 0,34,35,36, 0,37, 0, 0,23,23,23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,17,17,17,17,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,18,18,18,18,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,19,19,19,19,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,20,20,20,20,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,21,21,21,21,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,22,22,22,22,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23,23,23,23,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,38,38,38,38,38,38,38,38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,24,24,24,24,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,25,25,25,25,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,26,26,26,26,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,27,27,27,27,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,28,28,28,28,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,29,29,29,29,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,30,30,30,30,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,31,31,31,31,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,32,32,32,32,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,33,33,33,33,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,34,34,34,34,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,41,41,41,41,41,41,41,41,41,41, 0, 0, 0, 0, 0, 0, 0,41,41,41,41,41,41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,41,41,41,41,41,41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,35,35,35,35,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,36,36,36,36,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,43,43,43,43,43,43,43,43,43,43, 0, 0, 0, 0, 0, 0, 0,43,43,43,43,43,43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,43,43,43,43,43,43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,37,37,37,37,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,44,44,44,44,44,44,44,44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,38,38,38,38,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45, 0, 0, 0, 0,45, 0,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,39,39,39,39,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46, 0, 0, 0, 0,46, 0,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,40,40,40,40,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,47,47,47,47,47,47,47,47,47,47, 0, 0, 0, 0, 0, 0, 0,47,47,47,47,47,47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,47,47,47,47,47,47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,41,41,41,41,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,48,48,48,48,48,48,48,48,48,48, 0, 0, 0, 0, 0, 0, 0,48,48,48,48,48,48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,48,48,48,48,48,48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,42,42,42,42,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,49,49,49,49,49,49,49,49,49,49, 0, 0, 0, 0, 0, 0, 0,49,49,49,49,49,49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,49,49,49,49,49,49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,43,43,43,43,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,44,44,44,44,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,50,50,50,50,50,50,50,50,50,50, 0, 0, 0, 0, 0, 0, 0,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50, 0, 0, 0, 0,50, 0,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50, 0, 0,51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,45,45,45,45,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,52,52,52,52,52,52,52,52,52,52, 0, 0, 0, 0, 0, 0, 0,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52, 0, 0, 0, 0,52, 0,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52, 0, 0,53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,46,46,46,46,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,54,54,54,54,54,54,54,54,54,54, 0, 0, 0, 0, 0, 0, 0,54,54,54,54,54,54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,54,54,54,54,54,54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,47,47,47,47,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,48,48,48,48,48,48,48,48,48,48, 0, 0, 0, 0, 0, 0, 0,48,48,48,48,48,48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,48,48,48,48,48,48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,48,48,48,48,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,49,49,49,49,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,50,50,50,50,50,50,50,50,50,50, 0, 0, 0, 0, 0, 0, 0,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50, 0, 0, 0, 0,50, 0,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50, 0, 0,51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,50,50,50,50,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,51,51,51,51,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,52,52,52,52,52,52,52,52,52,52, 0, 0, 0, 0, 0, 0, 0,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52, 0, 0, 0, 0,52, 0,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52,52, 0, 0,53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,52,52,52,52,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,53,53,53,53,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,56,56,56,56,56,56,56,56,56,56, 0, 0, 0, 0, 0, 0, 0,56,56,56,56,56,56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,56,56,56,56,56,56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,54,54,54,54,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,55,55,55,55,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,56,56,56,56
};
static const size_t rex_scan_actions_rex[] = { 0, 0, 36, 36, 37, 6, 1, 2, 12, 13, 17, 10, 5, 17, 18, 14, 3, 37, 4, 7, 15, 11, 16, 26, 31, 8, 0, 9, 19, 20, 21, 22, 0, 23, 24, 0, 25, 0, 32, 0, 0, 0, 0, 27, 33, 0, 0, 0, 0, 28, 0, 35, 0, 34, 0, 30, 29 };
static const int rex_minimum_sym = 3;
static const size_t rex_num_columns = 31;
static const size_t rex_num_rows = 33;
static const size_t rex_num_productions = 25;
static const int rex_parse_table[] = {
   -5,  0, -5,  0, 0, 0, -5, -5, -5, 0, -5,  0,  0,  0, 0, 0, -5, -5, 0, -5, -5, 0, -5, 1, 2,32, 0, 0, 0, 0, 0,
    0,  0,  0,  0, 0, 0,  0,  0,  0, 0,  0,  0,  0,  0, 0, 0,  0,  0, 0,  0,  0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0,
    0,  0,  0,  0, 0, 0,  0,  0,  0, 0, 16,  0,  0,  0, 0, 0,  0,  0, 0,  0,  0, 0, -2, 0, 0, 0, 0, 0, 0, 0, 0,
   -6, -6, -6,  0, 0, 0, -6, -6, -6, 0, -6,  0,  0,  0, 0, 0, -6, -6, 0, -6, -6, 0, -6, 0, 0, 0, 0, 0, 0, 0, 0,
   -8, -8, -8,  0, 0, 0, -8, -8, -8, 0, -8,  0,  0,  0, 0, 0, -8, -8, 0, -8, -8, 0, -8, 0, 0, 0, 0, 0, 0, 0, 0,
   -9, -9, -9,  0, 0, 0, -9, -9, -9, 0, -9,  0,  0,  0, 0, 0, -9, -9, 0, -9, -9, 0, -9, 0, 0, 0, 0, 0, 0, 0, 0,
  -10,-10,-10,  0, 0, 0,-10,-10,-10, 0,-10,  0,  0,  0, 0, 0,-10,-10, 0,-10,-10, 0,-10, 0, 0, 0, 0, 0, 0, 0, 0,
   -7, -7, -7,  0, 0, 0, -7, -7, -7, 0, -7,  4,  5,  6, 0, 0, -7, -7, 0, -7, -7, 0, -7, 0, 0, 0, 0, 0, 0, 0, 0,
  -11,-11,-11,  0, 0, 0,-11,-11,-11, 0,-11,-11,-11,-11, 0, 0,-11,-11, 0,-11,-11, 0,-11, 0, 0, 0, 0, 0, 0, 0, 0,
  -12,-12,-12,  0, 0, 0,-12,-12,-12, 0,-12,-12,-12,-12, 0, 0,-12,-12, 0,-12,-12, 0,-12, 0, 0, 0, 0, 0, 0, 0, 0,
  -13,-13,-13,  0, 0, 0,-13,-13,-13, 0,-13,-13,-13,-13, 0, 0,-13,-13, 0,-13,-13, 0,-13, 0, 0, 0, 0, 0, 0, 0, 0,
  -14,-14,-14,  0, 0, 0,-14,-14,-14, 0,-14,-14,-14,-14, 0, 0,-14,-14, 0,-14,-14, 0,-14, 0, 0, 0, 0, 0, 0, 0, 0,
  -15,-15,-15,  0, 0, 0,-15,-15,-15, 0,-15,-15,-15,-15, 0, 0,-15,-15, 0,-15,-15, 0,-15, 0, 0, 0, 0, 0, 0, 0, 0,
  -16,-16,-16,  0, 0, 0,-16,-16,-16, 0,-16,-16,-16,-16, 0, 0,-16,-16, 0,-16,-16, 0,-16, 0, 0, 0, 0, 0, 0, 0, 0,
  -17,-17,-17,  0, 0, 0,-17,-17,-17, 0,-17,-17,-17,-17, 0, 0,-17,-17, 0,-17,-17, 0,-17, 0, 0, 0, 0, 0, 0, 0, 0,
   19, -4, 31,  0, 0, 0, 10, 12, 11, 0, -4,  0,  0,  0, 0, 0,  8,  9, 0, 13, 14, 0, -4, 0, 0, 0, 3, 7, 0, 0, 0,
   -5, -5, -5,  0, 0, 0, -5, -5, -5, 0, -5,  0,  0,  0, 0, 0, -5, -5, 0, -5, -5, 0, -5, 0, 0,15, 0, 0, 0, 0, 0,
  -18,-18,-18,  0, 0, 0,-18,-18,-18, 0,-18,-18,-18,-18, 0, 0,-18,-18, 0,-18,-18, 0,-18, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 17,  0,  0, 0, 0,  0,  0,  0, 0, 16,  0,  0,  0, 0, 0,  0,  0, 0,  0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,
   -5, -5, -5,  0, 0, 0, -5, -5, -5, 0, -5,  0,  0,  0, 0, 0, -5, -5, 0, -5, -5, 0,  0, 0,18,32, 0, 0, 0, 0, 0,
  -19,-19,-19,  0, 0, 0,-19,-19,-19, 0,-19,-19,-19,-19, 0, 0,-19,-19, 0,-19,-19, 0,-19, 0, 0, 0, 0, 0, 0, 0, 0,
    0,  0,  0, 20, 0, 0,  0,  0,  0, 0,  0,  0,  0,  0, 0, 0, 28, 29, 0,  0,  0, 0,  0, 0, 0, 0, 0, 0, 0,23, 0,
  -20,-20,-20,  0, 0, 0,-20,-20,-20, 0,-20,-20,-20,-20, 0, 0,-20,-20, 0,-20,-20, 0,-20, 0, 0, 0, 0, 0, 0, 0, 0,
    0,  0,  0,-21, 0, 0,  0,  0,  0, 0,  0,  0,  0,  0, 0, 0,-21,-21, 0,  0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,  0,  0, 22, 0, 0,  0,  0,  0, 0,  0,  0,  0,  0, 0, 0, 28, 29, 0,  0,  0, 0,  0, 0, 0, 0, 0, 0, 0,23, 0,
    0,  0,  0,-22, 0, 0,  0,  0,  0, 0,  0,  0,  0,  0, 0, 0,-22,-22, 0,  0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,  0,  0,-25, 0, 0,  0,  0,  0, 0,  0,  0,  0,  0, 0, 0,-25,-25, 0,  0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,  0,  0,  0, 0, 0,  0,  0,  0, 0,  0,  0,  0,  0, 0, 0, 26,  0, 0,  0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,  0,  0,-23, 0, 0,  0,  0,  0,27,  0,  0,  0,  0, 0, 0,-23,-23, 0,  0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,  0,  0,-24, 0, 0,  0,  0,  0, 0,  0,  0,  0,  0, 0, 0,-24,-24, 0,  0,  0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,  0,  0,  0, 0, 0,  0,  0,  0, 0,  0,  0,  0,  0, 0, 0, 28, 29, 0,  0,  0, 0,  0, 0, 0, 0, 0, 0,24,25, 0,
    0,  0,  0,  0, 0, 0,  0,  0, 30, 0,  0,  0,  0,  0, 0, 0, 28, 29, 0,  0,  0, 0,  0, 0, 0, 0, 0, 0,21,25, 0,
   19, -3, 31,  0, 0, 0, 10, 12, 11, 0, -3,  0,  0,  0, 0, 0,  8,  9, 0, 13, 14, 0, -3, 0, 0, 0, 3, 7, 0, 0, 0,
};
static const size_t rex_production_lengths[] = {
  1,
  1,
  1,
  3,
  0,
  2,
  1,
  2,
  2,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  3,
  3,
  4,
  2,
  1,
  1,
  1,
  3
};
static const int rex_production_syms[] = {
  33,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  29,
  29,
  30,
  30,
  30,
  30,
  30,
  30,
  30,
  30,
  30,
  30,
  31,
  31,
  32,
  32,
  32
};

#ifndef CARB_REX_REX_PARSE_H_INCLUDED
struct rex_stack {
  int error_recovery_:1;
  int pending_reset_:1;
  int discard_remaining_actions_:1;
  int slot_1_has_sym_data_:1;
  int slot_1_has_common_data_:1;
  int top_of_stack_has_sym_data_:1;
  int top_of_stack_has_common_data_:1;
  int need_sym_:1;
  int is_final_input_:1;
  int slot_0_has_current_sym_data_:1;
  int slot_0_has_common_data_:1;
  int current_sym_;
  size_t input_size_;
  const char *input_;
  int slot_1_sym_;
  int continue_at_;
  int mute_error_turns_;
  size_t pos_, num_stack_allocated_;
  struct rex_sym_data *stack_;
  struct rex_sym_data *sym_data_;
  size_t current_production_length_;
  int current_production_nonterminal_;
  size_t scan_state_;
  size_t current_mode_start_state_;
  size_t match_index_;
  size_t best_match_action_;
  size_t best_match_size_;
  size_t input_index_;
  size_t input_offset_;
  size_t match_buffer_size_;
  size_t match_buffer_size_allocated_;
  /* offset, line and column at the start of match_buffer_ */
  size_t match_offset_;
  int match_line_;
  int match_col_;
  /* offset, line and column at the zero-termination (best_match_size_) of a match 
  * in match_buffer_ (the actual buffer may well be longer.) */
  size_t best_match_offset_;
  int best_match_line_;
  int best_match_col_;
  size_t token_size_;
  char *match_buffer_;
  char terminator_repair_;
  int input_line_;
  int input_col_;
  int sym_grp_;
  char codepoint_[4];
  char *cp_;
};
#define _REX_FINISH 0
#define _REX_MATCH 1
#define _REX_OVERFLOW 2
#define _REX_NO_MEMORY 3
#define _REX_FEED_ME 4
#define _REX_END_OF_INPUT 5
#define _REX_SYNTAX_ERROR 6
#define _REX_LEXICAL_ERROR 7
#define _REX_INTERNAL_ERROR 8

#define REX_PAR_OPEN 3
#define REX_PAR_CLOSE 4
#define REX_SQBRACE_OPEN 5
#define REX_SQBRACE_CLOSE 6
#define REX_CUBRACE_OPEN 7
#define REX_CUBRACE_CLOSE 8
#define REX_DOT 9
#define REX_DOLLAR 10
#define REX_CARET 11
#define REX_DASH 12
#define REX_BAR 13
#define REX_ASTERISK 14
#define REX_PLUS 15
#define REX_QUESTION_MARK 16
#define REX_RESERVED_REGEX_CHAR 17
#define REX_SEMICOLON 18
#define REX_CHAR 19
#define REX_CATEGORY 20
#define REX_WHITESPACE 21
#define REX_START_OF_INPUT_ESC 22
#define REX_END_OF_INPUT_ESC 23
#define REX_ERROR 24
#define REX_INPUT_END 25

#define REX_REGEX 26
#define REX_EXP 27
#define REX_TERM 28
#define REX_ELM 29
#define REX_SYM 30
#define REX_RANGE 31
#define REX_RANGE_ELM 32

#define M_REX_DEFAULT 1

#endif /* CARB_REX_REX_PARSE_H_INCLUDED */

void rex_stack_init(struct rex_stack *stack) {
  stack->error_recovery_ = 0;
  stack->pending_reset_ = 1;
  stack->discard_remaining_actions_ = 0;
  stack->need_sym_ = 1;
  stack->current_sym_ = 0;
  stack->input_ = NULL;
  stack->input_size_ = 0;
  stack->is_final_input_ = 0;
  stack->slot_1_has_sym_data_ = stack->slot_1_has_common_data_ = 0;
  stack->slot_1_sym_ = 0;
  stack->top_of_stack_has_sym_data_ = stack->top_of_stack_has_common_data_ = 0;
  stack->continue_at_ = 0;
  stack->mute_error_turns_ = 0;
  stack->pos_ = 0;
  stack->num_stack_allocated_ = 0;
  stack->stack_ = NULL;
  stack->sym_data_ = NULL;
  stack->current_production_length_ = 0;
  stack->current_production_nonterminal_ = 0;
  stack->slot_0_has_current_sym_data_ = stack->slot_0_has_common_data_ = 0;
  stack->current_mode_start_state_ = M_REX_DEFAULT;
  stack->scan_state_ = stack->current_mode_start_state_;
  stack->input_index_ = 0;
  stack->input_offset_ = 0;
  stack->input_line_ = 1;
  stack->input_col_ = 1;
  stack->sym_grp_ = 0;
  stack->cp_ = stack->codepoint_;
  stack->match_index_ = 0;
  stack->match_buffer_ = NULL;
  stack->match_buffer_size_ = 0;
  stack->match_buffer_size_allocated_ = 0;
  stack->terminator_repair_ = '\0';
  stack->token_size_ = 0;
  stack->match_offset_ = 0;
  stack->match_line_ = 1;
  stack->match_col_ = 1;
  stack->best_match_action_ = 0;
  stack->best_match_size_ = 0;
  stack->best_match_offset_ = 0;
  stack->best_match_line_ = 1;
  stack->best_match_col_ = 1;
}

void rex_stack_cleanup(struct rex_stack *stack) {
  size_t n;
  for (n = 2; n < stack->pos_; ++n) {
    if ((n != (stack->pos_ - 1)) || stack->top_of_stack_has_sym_data_) {
      switch (stack->stack_[n].state_) {
        case 21: /* range */
        case 23: /* range-elm */
        case 24: /* range */
        case 25: /* range-elm */
        {
          {
             rex_set_range_cleanup(&((stack->stack_ + n)->v_.uv3_));
          }
          
        }
        break;
      } /* switch */
    }
  }
  if (stack->slot_1_has_sym_data_) {
    switch (stack->slot_1_sym_) {
      case 27:
      case 28:
      case 29:
      case 30:
      break;
      case 19:
      break;
      case 20:
      break;
      case 32:
      case 31:
      {
        {
           rex_set_range_cleanup(&(stack->stack_[1].v_.uv3_));
        }
        
      }
      break;
    } /* switch */
  }
  if (stack->slot_0_has_current_sym_data_) {
    /* Deconstruct placeholder location for terminal not yet shifted */
    switch (stack->current_sym_) {
      case 27:
      case 28:
      case 29:
      case 30:
      break;
      case 19:
      break;
      case 20:
      break;
      case 32:
      case 31:
      {
        {
           rex_set_range_cleanup(&(stack->stack_[0].v_.uv3_));
        }
        
      }
      break;
    } /* switch */
  }
  
  if (stack->stack_) free(stack->stack_);
  if (stack->match_buffer_) free(stack->match_buffer_);
}

static int rex_push_state(struct rex_stack *stack, int state) {
  if (stack->num_stack_allocated_ == stack->pos_) {
    size_t new_num_allocated = 0;
    if (stack->num_stack_allocated_) {
      new_num_allocated = stack->num_stack_allocated_ * 2;
      if (new_num_allocated <= stack->num_stack_allocated_) {
        /* Overflow in allocation */
        return _REX_OVERFLOW;
      }
    }
    else {
      new_num_allocated = 16;
    }
    
    if (new_num_allocated > (SIZE_MAX / sizeof(struct rex_sym_data))) {
      /* Overflow in allocation */
      return _REX_OVERFLOW;
    }
    
    void *p = realloc(stack->stack_, new_num_allocated * sizeof(struct rex_sym_data));
    if (!p) {
      /* Out of memory */
      return _REX_NO_MEMORY;
    }
    stack->stack_ = (struct rex_sym_data *)p;
    stack->num_stack_allocated_ = new_num_allocated;
  }
  stack->stack_[stack->pos_++].state_ = state;
  return 0;
}

int rex_stack_reset(struct rex_stack *stack) {
  size_t n;
  stack->pending_reset_ = 0;
  stack->discard_remaining_actions_ = 0;
  for (n = 2; n < stack->pos_; ++n) {
    if ((n != (stack->pos_ - 1)) || stack->top_of_stack_has_sym_data_) {
      switch (stack->stack_[n].state_) {
        case 21: /* range */
        case 23: /* range-elm */
        case 24: /* range */
        case 25: /* range-elm */
        {
          {
             rex_set_range_cleanup(&((stack->stack_ + n)->v_.uv3_));
          }
          
        }
        break;
      } /* switch */
    }
  }
  if (stack->slot_1_has_sym_data_) {
    switch (stack->slot_1_sym_) {
      case 27:
      case 28:
      case 29:
      case 30:
      break;
      case 19:
      break;
      case 20:
      break;
      case 32:
      case 31:
      {
        {
           rex_set_range_cleanup(&(stack->stack_[1].v_.uv3_));
        }
        
      }
      break;
    } /* switch */
  }
  stack->slot_1_has_sym_data_ = stack->slot_1_has_common_data_ = 0;
  stack->slot_1_sym_ = 0;
  stack->top_of_stack_has_sym_data_ = 0;
  stack->top_of_stack_has_common_data_ = 0;
  if (stack->slot_0_has_current_sym_data_) {
    /* Deconstruct placeholder location for terminal not yet shifted */
    switch (stack->current_sym_) {
      case 27:
      case 28:
      case 29:
      case 30:
      break;
      case 19:
      break;
      case 20:
      break;
      case 32:
      case 31:
      {
        {
           rex_set_range_cleanup(&(stack->stack_[0].v_.uv3_));
        }
        
      }
      break;
    } /* switch */
  }
  stack->slot_0_has_current_sym_data_ = stack->slot_0_has_common_data_ = 0;
  stack->sym_data_ = NULL;
  stack->current_production_length_ = 0;
  stack->current_production_nonterminal_ = 0;
  stack->pos_ = 0;
  stack->error_recovery_ = 0;
  stack->need_sym_ = 1;
  stack->current_sym_ = 0;
  stack->continue_at_ = 0;
  stack->mute_error_turns_ = 0;
  /* reserve slot [0] for the token sym data */
  switch (rex_push_state(stack, 0)) {
    case _REX_OVERFLOW:{
      return _REX_OVERFLOW;
    }
    break;
    case _REX_NO_MEMORY: {
      return _REX_NO_MEMORY;
    }
    break;
  }
  /* reserve slot [1] for the initial state 0, corresponding to the synthetic S production
  ** sym_data in slot [1] is used for temporary nonterminal data storage */
  switch (rex_push_state(stack, 0)) {
    case _REX_OVERFLOW:{
      return _REX_OVERFLOW;
    }
    break;
    case _REX_NO_MEMORY: {
      return _REX_NO_MEMORY;
    }
    break;
  }
  stack->scan_state_ = stack->current_mode_start_state_;
  stack->input_offset_ = 0;
  stack->input_line_ = 1;
  stack->input_col_ = 1;
  stack->match_index_ = 0;
  stack->match_buffer_size_ = 0;
  stack->terminator_repair_ = '\0';
  stack->token_size_ = 0;
  stack->match_offset_ = 0;
  stack->match_line_ = 1;
  stack->match_col_ = 1;
  stack->best_match_action_ = 0;
  stack->best_match_size_ = 0;
  stack->best_match_offset_ = 0;
  stack->best_match_line_ = 1;
  stack->best_match_col_ = 1;
  stack->sym_grp_ = 0;
  stack->cp_ = stack->codepoint_;
  return 0;
}

int rex_stack_can_recover(struct rex_stack *stack) {
  return !!stack->error_recovery_;
}

int rex_stack_accepts(struct rex_stack *stack, int sym) {
  if (!stack->pos_) return 0;
  return 0 != rex_parse_table[rex_num_columns * stack->stack_[stack->pos_ - 1].state_ + (sym - rex_minimum_sym)];}

void rex_set_mode(struct rex_stack *stack, int mode) {
  if (stack->current_mode_start_state_ == stack->scan_state_) {
    stack->scan_state_ = mode;
  }
  stack->current_mode_start_state_ = mode;
}

int rex_mode(struct rex_stack *stack) {
  return (int)stack->current_mode_start_state_;
}

static int rex_append_match_buffer(struct rex_stack *stack, const char *s, size_t len) {
  size_t size_needed = len;
  size_needed += stack->match_buffer_size_;
  if (size_needed < stack->match_buffer_size_) {
    return _REX_OVERFLOW;
  }
  if (size_needed == SIZE_MAX) {
    /* cannot fit null terminator */
    return _REX_OVERFLOW;
  }
  size_needed++; /* null terminator */
  if (size_needed < 128) {
    size_needed = 128;
  }
  if (size_needed > stack->match_buffer_size_allocated_) {
    /* intent of code: grow buffer size by powers of 2-1, unless our needs require more now. */
    size_t size_to_allocate = stack->match_buffer_size_allocated_ * 2 + 1;
    if (size_to_allocate <= stack->match_buffer_size_allocated_) {
      return _REX_OVERFLOW;
    }
    if (size_to_allocate < size_needed) {
      size_to_allocate = size_needed;
    }
    void *buf = realloc(stack->match_buffer_, size_to_allocate);
    if (!buf) {
      return _REX_NO_MEMORY;
    }
    stack->match_buffer_ = (char *)buf;
    stack->match_buffer_size_allocated_ = size_to_allocate;
  }
  
  memcpy(stack->match_buffer_ + stack->match_buffer_size_, s, len);
  stack->match_buffer_size_ += len;
  stack->match_buffer_[stack->match_buffer_size_] = '\0';
  return 0;
}

void rex_set_input(struct rex_stack *stack, const char *input, size_t input_size, int is_final_input) {
  stack->input_ = input;
  stack->input_size_ = input_size;
  stack->is_final_input_ = is_final_input;
  stack->input_index_ = 0;
}

void rex_set_location(struct rex_stack *stack, int line, int col, size_t offset) {
  if (stack->token_size_) {
    /* Parsing of next token not in progress, set end location of this token as
    ** it will be the start of the next token. */
    stack->input_line_ = stack->input_line_ - stack->best_match_line_ + line;
    stack->input_col_ = stack->input_col_ - stack->best_match_col_ + col;
    stack->input_offset_ = stack->input_offset_ - stack->best_match_offset_ + offset;
    
    stack->best_match_line_ = line;
    stack->best_match_col_ = col;
    stack->best_match_offset_ = offset;
    return;
  }
  /* Parsing of token in progress, dynamically move the start of the token, as
  ** well as the relative current partial end of the token, to the desired location. */
  stack->input_line_ = stack->input_line_ - stack->match_line_ + line;
  stack->input_col_ = stack->input_col_ - stack->match_col_ + col;
  stack->input_offset_ = stack->input_offset_ - stack->match_offset_ + offset;
  
  stack->best_match_line_ = stack->best_match_line_ - stack->match_line_ + line;
  stack->best_match_col_ = stack->best_match_col_ - stack->match_col_ + col;
  stack->best_match_offset_ = stack->best_match_offset_ - stack->match_offset_ + offset;
  stack->match_line_ = line;
  stack->match_col_ = col;
  stack->match_offset_ = offset;
}

const char *rex_text(struct rex_stack *stack) {
  return stack->match_buffer_;
}

size_t rex_len(struct rex_stack *stack) {
  return stack->token_size_;
}

int rex_line(struct rex_stack *stack) {
  return stack->match_line_;
}

int rex_column(struct rex_stack *stack) {
  return stack->match_col_;
}

size_t rex_offset(struct rex_stack *stack) {
  return stack->match_offset_;
}

int rex_endline(struct rex_stack *stack) {
  return stack->best_match_line_;
}

int rex_endcolumn(struct rex_stack *stack) {
  return stack->best_match_col_;
}

size_t rex_endoffset(struct rex_stack *stack) {
  return stack->best_match_offset_;
}

int rex_lex(struct rex_stack *stack) {
  int r;
  unsigned char c;
  const char *input = stack->input_;
  size_t input_size = stack->input_size_;
  int is_final_input = !!stack->is_final_input_;
  size_t scan_state = stack->scan_state_;
  const int *transition_table = rex_scan_table_grouped_rex_;
  const size_t *actions = rex_scan_actions_rex;
  const size_t row_size = rex_num_scan_table_grouped_columns_;
  const size_t default_action = 0;
  const size_t start_state = 1;
  const size_t start_action = 0;
  char *cp = stack->cp_;
  
  size_t match_index = stack->match_index_;
  
  size_t best_match_action = stack->best_match_action_;
  size_t best_match_size = stack->best_match_size_;
  size_t best_match_offset = stack->best_match_offset_;
  int best_match_line = stack->best_match_line_;
  int best_match_col = stack->best_match_col_;
  
  size_t input_index = stack->input_index_;
  size_t input_offset = stack->input_offset_;
  int input_line = stack->input_line_;
  int input_col = stack->input_col_;
  
  int symgrp = stack->sym_grp_;
  
  /* Move any prior token out of the way */
  if (stack->token_size_) {
    stack->match_buffer_[stack->token_size_] = stack->terminator_repair_;
    
    memcpy(stack->match_buffer_, stack->match_buffer_ + stack->token_size_, stack->match_buffer_size_ - stack->token_size_);
    stack->match_buffer_size_ -= stack->token_size_;
    stack->match_offset_ = stack->best_match_offset_;
    stack->match_line_ = stack->best_match_line_;
    stack->match_col_ = stack->best_match_col_;
    
    /* Reset scanner to get ready for next token */
    stack->match_index_ = match_index = 0;
    stack->best_match_action_ = best_match_action = start_action;
    stack->best_match_size_ = best_match_size = 0;
    stack->scan_state_ = scan_state = stack->current_mode_start_state_;
    stack->token_size_ = 0;
    
  }
  
  size_t at_match_index_offset = stack->match_offset_;
  int at_match_index_line = stack->match_line_;
  int at_match_index_col = stack->match_col_;
  while (match_index < stack->match_buffer_size_) {
    c = (unsigned char)stack->match_buffer_[match_index];
    int next_sg = rex_utf8_decoder_[256 * symgrp + c];
    if (next_sg >= 0 || !~next_sg) {
      if (next_sg >= 0) {
        /* Use next_sg as the new symgroup */
        match_index++;
        symgrp = next_sg;
        *cp++ = c;
      }
      else /* (!~next_sg) */ {
        /* Invalid encoding, set next_sg to the unused codepoint group, this will 
        * induce a syntax error in the transition_table. */
        next_sg = 0;
        if (!symgrp) {
          /* Eat at least 1 byte of input, otherwise we will not make progress; but
          * the byte that triggered an encoding error on a multi-byte codepoint should
          * be reconsidered as the starting byte on a new codepoint. */
          match_index++;
          *cp++ = c;
        }
      }
      
      for (;;) {
        /* Check for start of input */
        if ((transition_table[row_size * (1 + scan_state) - 4] != scan_state) && (!at_match_index_offset)) {
          scan_state = transition_table[row_size * (1 + scan_state) - 4];
        }
        /* Check for start of line */
        else if ((transition_table[row_size * (1 + scan_state) - 3] != scan_state) && (at_match_index_col == 1)) {
          scan_state = transition_table[row_size * (1 + scan_state) - 3];
        }
        /* Check for end of line */
        else if ((transition_table[row_size * (1 + scan_state) - 2] != scan_state) && ('\n' == stack->codepoint_[0])) {
          scan_state = transition_table[row_size * (1 + scan_state) - 2];
        }
        /* (No need to check for end of input; we have at least 1 character ahead) */
        else {
          break;
        }
      }
      size_t state_action = actions[scan_state];
      ptrdiff_t cp_len = cp - stack->codepoint_;
      if (state_action != default_action) /* replace with actual */ {
        best_match_action = state_action;
        best_match_size = match_index - cp_len;
        best_match_offset = at_match_index_offset;
        best_match_line = at_match_index_line;
        best_match_col = at_match_index_col;
      }
      scan_state = transition_table[row_size * scan_state + symgrp];
      /* reset decoder */
      symgrp = 0;
      cp = stack->codepoint_;
      if (scan_state) {
        at_match_index_offset += (size_t)cp_len;
        if (stack->codepoint_[0] != '\n') {
          at_match_index_col++;
        }
        else {
          at_match_index_col = 1;
          at_match_index_line++;
        }
      }
      else {
        /* error, or, end of token, depending on whether we have a match before */
        if (best_match_action == default_action) {
          goto syntax_error;
        }
        
        /* Ensure token match is null terminated */
        stack->terminator_repair_ = stack->match_buffer_[best_match_size];
        stack->match_buffer_[best_match_size] = '\0';
        stack->token_size_ = best_match_size;
        stack->best_match_action_ = best_match_action;
        stack->best_match_size_ = best_match_size;
        stack->best_match_offset_ = best_match_offset;
        stack->best_match_line_ = best_match_line;
        stack->best_match_col_ = best_match_col;
        
        stack->input_index_ = input_index;
        stack->input_offset_ = input_offset;
        stack->input_line_ = input_line;
        stack->input_col_ = input_col;
        
        stack->cp_ = cp;
        stack->sym_grp_ = symgrp;
        
        return _REX_MATCH;
      }
    }
    else /* (next_sg < 0) */ {
      /* Partial analysis of codepoint; keep going */
      *cp++ = c;
      match_index++;
      symgrp = ~next_sg;
    }
  }
  while (input_index < input_size) {
    c = (unsigned char)input[input_index];
    int next_sg = rex_utf8_decoder_[256 * symgrp + c];
    if ((next_sg >= 0) || !~next_sg) {
      if (next_sg >= 0) {
        /* Use next_sg as the new symgroup */
        input_index++;
        symgrp = next_sg;
        *cp++ = c;
      }
      else /* (!~next_sg) */ {
        /* Invalid encoding, set next_sg to the unused codepoint group, this will 
        * induce a syntax error in the transition_table. */
        next_sg = 0;
        if (!symgrp) {
          /* Eat at least 1 byte of input, otherwise we will not make progress; but
          * the byte that triggered an encoding error on a multi-byte codepoint should
          * be reconsidered as the starting byte on a new codepoint. */
          input_index++;
          *cp++ = c;
        }
      }
      
      for (;;) {
        /* Check for start of input */
        if ((transition_table[row_size * (1 + scan_state) - 4] != scan_state) && (!input_offset)) {
          scan_state = transition_table[row_size * (1 + scan_state) - 4];
        }
        /* Check for start of line */
        else if ((transition_table[row_size * (1 + scan_state) - 3] != scan_state) && (input_col == 1)) {
          scan_state = transition_table[row_size * (1 + scan_state) - 3];
        }
        /* Check for end of line */
        else if ((transition_table[row_size * (1 + scan_state) - 2] != scan_state) && ('\n' == stack->codepoint_[0])) {
          scan_state = transition_table[row_size * (1 + scan_state) - 2];
        }
        /* (No need to check for end of input; we have at least 1 character ahead) */
        else {
          break;
        }
      }
      size_t state_action = actions[scan_state];
      ptrdiff_t cp_len = cp - stack->codepoint_;
      if (state_action != default_action) /* replace with actual */ {
        best_match_action = state_action;
        best_match_size = stack->match_buffer_size_ + input_index - stack->input_index_ - cp_len;
        best_match_offset = input_offset;
        best_match_col = input_col;
        best_match_line = input_line;
      }
      scan_state = transition_table[row_size * scan_state + symgrp];
      /* Reset decoder */
      symgrp = 0;
      cp = stack->codepoint_;
      /* We advanced input_index by a codepoint and so must process line and col to keep them in sync. */
      input_offset += (size_t)cp_len;
      if (stack->codepoint_[0] != '\n') {
        input_col++;
      }
      else {
        input_col = 1;
        input_line++;
      }
      if (!scan_state) {
        /* Append from stack->input_index_ to input_index, excluding input_index itself */
        r = rex_append_match_buffer(stack, input + stack->input_index_, input_index - stack->input_index_);
        if (r) return r;
        
        if (best_match_action == default_action) {
          goto syntax_error;
        }
        
        /* Ensure token match is null terminated, note that the size we just appended may
        * (likely) be longer than the last section we matched. */
        stack->terminator_repair_ = stack->match_buffer_[best_match_size];
        stack->match_buffer_[best_match_size] = '\0';
        stack->token_size_ = best_match_size;
        stack->best_match_action_ = best_match_action;
        stack->best_match_size_ = best_match_size;
        stack->best_match_offset_ = best_match_offset;
        stack->best_match_line_ = best_match_line;
        stack->best_match_col_ = best_match_col;
        
        stack->input_index_ = input_index;
        stack->input_offset_ = input_offset;
        stack->input_line_ = input_line;
        stack->input_col_ = input_col;
        
        stack->cp_ = cp;
        stack->sym_grp_ = symgrp;
        
        return _REX_MATCH;
      }
    }
    else /* (next_sg < 0) */ {
      /* Partial analysis of codepoint; keep going */
      *cp++ = c;
      input_index++;
      symgrp = ~next_sg;
    }
  }
  
  r = rex_append_match_buffer(stack, input + stack->input_index_, input_index - stack->input_index_);
  if (r) return r;
  
  /* Resume scanning after the input already processed. */
  match_index = stack->match_buffer_size_;
  
  if (!is_final_input) {
    /* Need more input */
    stack->scan_state_ = scan_state;
    stack->token_size_ = 0; /* no match yet */
    stack->input_index_ = input_index;
    stack->input_offset_ = input_offset;
    stack->input_line_ = input_line;
    stack->input_col_ = input_col;
    
    stack->best_match_action_ = best_match_action;
    stack->best_match_size_ = best_match_size;
    stack->best_match_offset_ = best_match_offset;
    stack->best_match_line_ = best_match_line;
    stack->best_match_col_ = best_match_col;
    
    stack->match_index_ = match_index;
    
    stack->cp_ = cp;
    stack->sym_grp_ = symgrp;
    
    return _REX_FEED_ME;
  }
  for (;;) {
    /* Check for start of input */
    if ((transition_table[row_size * (1 + scan_state) - 4] != scan_state) && (!input_offset)) {
      scan_state = transition_table[row_size * (1 + scan_state) - 4];
    }
    /* Check for start of line */
    else if ((transition_table[row_size * (1 + scan_state) - 3] != scan_state) && (input_col == 1)) {
      scan_state = transition_table[row_size * (1 + scan_state) - 3];
    }
    /* Check for end of line (always true at end of input) */
    else if (transition_table[row_size * (1 + scan_state) - 2] != scan_state) {
      scan_state = transition_table[row_size * (1 + scan_state) - 2];
    }
    /* Check for end of input (always true) */
    else if (transition_table[row_size * (1 + scan_state) - 1] != scan_state) {
      scan_state = transition_table[row_size * (1 + scan_state) - 1];
    }
    /* (No need to check for end of input; we have at least 1 character ahead) */
    else {
      break;
    }
  }
  size_t state_action = actions[scan_state];
  if (state_action != default_action) /* replace with actual */ {
    best_match_action = state_action;
    best_match_size = stack->match_buffer_size_;
    best_match_offset = input_offset;
    best_match_col = input_col;
    best_match_line = input_line;
  }
  
  if (!stack->match_buffer_size_ && (stack->input_index_ == input_size)) {
    /* Exhausted all input - leave stack in a state where we can
    * immediately re-use it in its initial state */
    stack->match_index_ = 0;
    stack->best_match_action_ = best_match_action = start_action;
    stack->best_match_size_ = best_match_size;
    stack->best_match_offset_ = best_match_offset;
    stack->best_match_line_ = best_match_line;
    stack->best_match_col_ = best_match_col;
    stack->scan_state_ = scan_state = stack->current_mode_start_state_;
    
    stack->token_size_ = 0;
    stack->input_offset_ = input_offset;
    stack->input_line_ = input_line;
    stack->input_col_ = input_col;
    stack->cp_ = cp;
    stack->sym_grp_ = symgrp;
    
    return _REX_END_OF_INPUT;
  }
  
  if (best_match_action == default_action) {
    goto syntax_error;
  }
  
  /* Ensure token match is null terminated */
  stack->terminator_repair_ = stack->match_buffer_[best_match_size];
  stack->match_buffer_[best_match_size] = '\0';
  stack->token_size_ = best_match_size;
  stack->best_match_action_ = best_match_action;
  stack->best_match_size_ = best_match_size;
  stack->best_match_offset_ = best_match_offset;
  stack->best_match_line_ = best_match_line;
  stack->best_match_col_ = best_match_col;
  
  stack->input_index_ = input_index;
  stack->input_offset_ = input_offset;
  stack->input_line_ = input_line;
  stack->input_col_ = input_col;
  stack->cp_ = cp;
  stack->sym_grp_ = symgrp;
  
  return _REX_MATCH;
  syntax_error:
  if (stack->match_buffer_size_) {
    stack->best_match_offset_ = stack->match_offset_ + 1;
    if (stack->match_buffer_[0] != '\n') {
      stack->best_match_line_ = stack->match_line_;
      stack->best_match_col_ = stack->match_col_ + 1;
    }
    else {
      stack->best_match_line_ = stack->match_line_ + 1;
      stack->best_match_col_ = 1;
    }
  }
  else {
    /* Append the single character causing the syntax error */
    r = rex_append_match_buffer(stack, input + stack->input_index_, 1);
    if (r) return r;
    
    input_offset++;
    if (input[stack->input_index_] != '\n') {
      input_col++;
    }
    else {
      input_col = 1;
      input_line++;
    }
    input_index = stack->input_index_ + 1;
    stack->best_match_offset_ = input_offset;
    stack->best_match_line_ = input_line;
    stack->best_match_col_ = input_col;
  }
  
  /* Reset scanner to get ready for next token */
  stack->token_size_ = 1;
  stack->terminator_repair_ = stack->match_buffer_[1];
  stack->match_buffer_[1] = '\0';
  
  stack->input_index_ = input_index;
  stack->input_offset_ = input_offset;
  stack->input_line_ = input_line;
  stack->input_col_ = input_col;
  stack->cp_ = cp;
  stack->sym_grp_ = symgrp;
  
  return _REX_LEXICAL_ERROR;
}

int rex_scan(struct rex_stack *stack, struct rex_nfa *nfa, size_t *pstart, size_t *pend) {
  if (stack->pending_reset_) {
    int r;
    r = rex_stack_reset(stack);
    if (r) return r;
  }
    switch (stack->continue_at_) {
    case 0: break; /* fall through to regular code path */
    case 1: goto C1;
    case 2: goto C2;
    case 3: goto C3;
    case 4: goto C4;
    case 5: goto C5;
    case 6: goto C6;
    case 7: goto C7;
    case 8: goto C8;
    case 9: goto C9;
    case 10: goto C10;
    case 11: goto C11;
    case 12: goto C12;
    case 13: goto C13;
    case 14: goto C14;
    case 15: goto C15;
    case 16: goto C16;
    case 17: goto C17;
    case 18: goto C18;
    case 19: goto C19;
    case 20: goto C20;
    case 21: goto C21;
    case 22: goto C22;
    case 23: goto C23;
    case 24: goto C24;
    case 25: goto C25;
    case 26: goto C26;
    case 27: goto C27;
    case 28: goto C28;
    case 29: goto C29;
    case 30: goto C30;
    case 31: goto C31;
    case 32: goto C32;
    case 33: goto C33;
    case 34: goto C34;
    case 35: goto C35;
    case 36: goto C36;
    case 37: goto C37;
    case 38: goto C38;
    case 39: goto C39;
    case 40: goto C40;
    case 41: goto C41;
    case 42: goto C42;
    case 43: goto C43;
    case 44: goto C44;
    case 45: goto C45;
    case 46: goto C46;
    case 47: goto C47;
    case 48: goto C48;
    case 49: goto C49;
    case 50: goto C50;
    case 51: goto C51;
  } /* continuation switch */
for (;;) {
    stack->continue_at_ = 0;
    if (stack->need_sym_) {
      switch (rex_lex(stack)) {
        case _REX_MATCH:
        stack->need_sym_ = 0;
        stack->discard_remaining_actions_ = 0;
        stack->current_sym_ = REX_INPUT_END; /* no sym specific type associated, changed when we successfully construct it below */
        if (stack->mute_error_turns_) stack->mute_error_turns_--;
        { /* scope guard */
          switch (stack->best_match_action_) {
            case 1: /* \( */
            stack->current_sym_ = REX_PAR_OPEN;
            break;
            case 2: /* \) */
            stack->current_sym_ = REX_PAR_CLOSE;
            break;
            case 3: /* \[ */
            stack->current_sym_ = REX_SQBRACE_OPEN;
            break;
            case 4: /* \] */
            stack->current_sym_ = REX_SQBRACE_CLOSE;
            break;
            case 5: /* \. */
            stack->current_sym_ = REX_DOT;
            break;
            case 6: /* \$ */
            stack->current_sym_ = REX_DOLLAR;
            break;
            case 7: /* \^ */
            stack->current_sym_ = REX_CARET;
            break;
            case 8: /* \\A */
            stack->current_sym_ = REX_START_OF_INPUT_ESC;
            break;
            case 9: /* \\Z */
            stack->current_sym_ = REX_END_OF_INPUT_ESC;
            break;
            case 10: /* \- */
            stack->current_sym_ = REX_DASH;
            break;
            case 11: /* \| */
            stack->current_sym_ = REX_BAR;
            break;
            case 12: /* \* */
            stack->current_sym_ = REX_ASTERISK;
            break;
            case 13: /* \+ */
            stack->current_sym_ = REX_PLUS;
            break;
            case 14: /* \? */
            stack->current_sym_ = REX_QUESTION_MARK;
            break;
            case 15: /* \{ */
            stack->current_sym_ = REX_CUBRACE_OPEN;
            break;
            case 16: /* \} */
            stack->current_sym_ = REX_CUBRACE_CLOSE;
            break;
            case 17: /* \,|\: */
            stack->current_sym_ = REX_RESERVED_REGEX_CHAR;
            break;
            case 18: /* \; */
            stack->current_sym_ = REX_SEMICOLON;
            break;
            case 19: /* \\a */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 1;
              {
                 (stack->stack_[0].v_.uv1_) = '\a'; 
              }
              C1:;
            }
            break;
            case 20: /* \\b */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 2;
              {
                 (stack->stack_[0].v_.uv1_) = '\b'; 
              }
              C2:;
            }
            break;
            case 21: /* \\f */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 3;
              {
                 (stack->stack_[0].v_.uv1_) = '\f'; 
              }
              C3:;
            }
            break;
            case 22: /* \\n */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 4;
              {
                 (stack->stack_[0].v_.uv1_) = '\n'; 
              }
              C4:;
            }
            break;
            case 23: /* \\r */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 5;
              {
                 (stack->stack_[0].v_.uv1_) = '\r'; 
              }
              C5:;
            }
            break;
            case 24: /* \\t */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 6;
              {
                 (stack->stack_[0].v_.uv1_) = '\t'; 
              }
              C6:;
            }
            break;
            case 25: /* \\v */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 7;
              {
                 (stack->stack_[0].v_.uv1_) = '\v'; 
              }
              C7:;
            }
            break;
            case 26: /* \\[\{\}\[\]\(\)\,\.\^\$\*\|\?\+\:\;\-\'\"\ \\] */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 8;
              {
                 (stack->stack_[0].v_.uv1_) = (uint32_t)(stack->match_buffer_)[1]; 
              }
              C8:;
            }
            break;
            case 27: /* \\x[0-9a-fA-F] */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 9;
              {
                 (stack->stack_[0].v_.uv1_) = hex_to_int((stack->match_buffer_) + 2, 1); 
              }
              C9:;
            }
            break;
            case 28: /* \\x[0-9a-fA-F][0-9a-fA-F] */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 10;
              {
                 (stack->stack_[0].v_.uv1_) = hex_to_int((stack->match_buffer_) + 2, 2); 
              }
              C10:;
            }
            break;
            case 29: /* \\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F] */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 11;
              {
                 (stack->stack_[0].v_.uv1_) = hex_to_int((stack->match_buffer_) + 2, 4); 
              }
              C11:;
            }
            break;
            case 30: /* \\u\{[0-9a-fA-F]+\} */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 12;
              {
                 (stack->stack_[0].v_.uv1_) = hex_to_int((stack->match_buffer_) + 3, (stack->token_size_) - 4); 
              }
              C12:;
            }
            break;
            case 31: /* \\[0-7] */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 13;
              {
                 (stack->stack_[0].v_.uv1_) = oct_to_int((stack->match_buffer_) + 1, 1); 
              }
              C13:;
            }
            break;
            case 32: /* \\[0-7][0-7] */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 14;
              {
                 (stack->stack_[0].v_.uv1_) = oct_to_int((stack->match_buffer_) + 1, 2); 
              }
              C14:;
            }
            break;
            case 33: /* \\[0-7][0-7][0-7] */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 15;
              {
                 (stack->stack_[0].v_.uv1_) = oct_to_int((stack->match_buffer_) + 1, 3); 
              }
              C15:;
            }
            break;
            case 34: /* \\p\{[a-zA-Z_][0-9a-zA-Z_]*\} */
            stack->current_sym_ = REX_CATEGORY;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 16;
              {
                 
  size_t first, last;
  if (!uc_cat_ranges_resolve_codepoint_category((stack->match_buffer_) + 3, (stack->token_size_) - 4, &first, &last)) {
    /* Could not find category */
    nfa->failed_ = _REX_SYNTAX_ERROR;
    return _REX_SYNTAX_ERROR;
  }
  (stack->stack_[0].v_.uv2_).is_inverted_ = 0;
  (stack->stack_[0].v_.uv2_).first_ = first;
  (stack->stack_[0].v_.uv2_).last_ = last;

              }
              C16:;
            }
            break;
            case 35: /* \\P\{[a-zA-Z_][0-9a-zA-Z_]*\} */
            stack->current_sym_ = REX_CATEGORY;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 17;
              {
                
  size_t first, last;
  if (!uc_cat_ranges_resolve_codepoint_category((stack->match_buffer_) + 3, (stack->token_size_) - 4, &first, &last)) {
    /* Could not find category */
    nfa->failed_ = _REX_SYNTAX_ERROR;
    return _REX_SYNTAX_ERROR;
  }
  (stack->stack_[0].v_.uv2_).is_inverted_ = 1; /* Capital P means inverted */
  (stack->stack_[0].v_.uv2_).first_ = first;
  (stack->stack_[0].v_.uv2_).last_ = last;

              }
              C17:;
            }
            break;
            case 36: /* [\ \x9\xb\xc\xd\r\n]+ */
            stack->current_sym_ = REX_WHITESPACE;
            break;
            case 37: /* [\x20-\x7e] */
            stack->current_sym_ = REX_CHAR;
            stack->slot_0_has_current_sym_data_ = 1;
            if (!stack->discard_remaining_actions_) {
              stack->continue_at_ = 18;
              {
                 (stack->stack_[0].v_.uv1_) = (stack->match_buffer_)[0]; 
              }
              C18:;
            }
            break;
          } /* switch */
        } /* scope guard */
        break;
        case _REX_OVERFLOW:
        stack->continue_at_ = 0;
        return _REX_OVERFLOW;
        case _REX_NO_MEMORY:
        stack->continue_at_ = 0;
        return _REX_NO_MEMORY;
        case _REX_FEED_ME:
        stack->continue_at_ = 0;
        /* Need more input */
        return _REX_FEED_ME;
        case _REX_END_OF_INPUT:
        stack->current_sym_ = REX_INPUT_END;
        stack->need_sym_ = 0;
        if (stack->mute_error_turns_) stack->mute_error_turns_--;
        break;
        case _REX_LEXICAL_ERROR:
        stack->continue_at_ = 0;
        /* Lexical error */
        return _REX_LEXICAL_ERROR;
      } /* switch */
    } /* if (need_sym_) */
    else {
      int sym = stack->current_sym_;
      if (!stack->error_recovery_) {
        int action = rex_parse_table[rex_num_columns * stack->stack_[stack->pos_ - 1].state_ + (sym - rex_minimum_sym)];
        if (action > 0) {
          switch (rex_push_state(stack, action)) {
            case _REX_OVERFLOW: {
              stack->continue_at_ = 0;
              return _REX_OVERFLOW;
            }
            break;
            case _REX_NO_MEMORY: {
              stack->continue_at_ = 0;
              return _REX_NO_MEMORY;
            }
            break;
          } /* switch */
          
          /* Fill in the sym from the tokenizer */
          stack->need_sym_ = 1;
          stack->stack_[stack->pos_ - 1].v_ = stack->stack_[0].v_;
          stack->slot_0_has_current_sym_data_ = 0;
          stack->slot_0_has_common_data_ = 0;
          stack->top_of_stack_has_sym_data_ = 1;
          stack->top_of_stack_has_common_data_ = 1;
        } /* action > 0 */
        else if (action < 0) {
          int production = -action - 1;
          stack->discard_remaining_actions_ = 0;
          stack->current_production_length_ = rex_production_lengths[production];
          stack->current_production_nonterminal_ = rex_production_syms[production];
          if (0 == production) {
            stack->pending_reset_ = 1;
            return _REX_FINISH;
          }
          
          memset(&stack->stack_[1], 0, sizeof(struct rex_sym_data));
          { /* scope guard */
            stack->sym_data_ = stack->stack_ + stack->pos_ - stack->current_production_length_;
            switch (production) {
              /* regex: exp */
              case 1: {
                stack->continue_at_ = 19;
                {
                  {
  *pstart = (stack->sym_data_[0].v_.uv0_).initial_;
  *pend = (stack->sym_data_[0].v_.uv0_).final_;
}
                }
                C19:;
              }
              break;
              /* exp: term */
              case 2: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_EXP;
                stack->continue_at_ = 20;
                {
                  { 
  (stack->stack_[1].v_.uv0_) = (stack->sym_data_[0].v_.uv0_); 
}
                }
                C20:;
              }
              break;
              /* exp: exp BAR term */
              case 3: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_EXP;
                stack->continue_at_ = 21;
                {
                  {
  size_t i, f;
  i = rex_nfa_make_node(nfa);
  f = rex_nfa_make_node(nfa);
  rex_nfa_make_empty_trans(nfa, i, (stack->sym_data_[0].v_.uv0_).initial_);
  rex_nfa_make_empty_trans(nfa, i, (stack->sym_data_[2].v_.uv0_).initial_);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, f);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[2].v_.uv0_).final_, f);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C21:;
              }
              break;
              /* term: */
              case 4: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_TERM;
                stack->continue_at_ = 22;
                {
                  {
  (stack->stack_[1].v_.uv0_).initial_ = rex_nfa_make_node(nfa);
  (stack->stack_[1].v_.uv0_).final_ = rex_nfa_make_node(nfa);
  rex_nfa_make_empty_trans(nfa, (stack->stack_[1].v_.uv0_).initial_, (stack->stack_[1].v_.uv0_).final_);
}
                }
                C22:;
              }
              break;
              /* term: term elm */
              case 5: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_TERM;
                stack->continue_at_ = 23;
                {
                  {
  (stack->stack_[1].v_.uv0_).initial_ = (stack->sym_data_[0].v_.uv0_).initial_;
  (stack->stack_[1].v_.uv0_).final_ = (stack->sym_data_[1].v_.uv0_).final_;
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, (stack->sym_data_[1].v_.uv0_).initial_);
}
                }
                C23:;
              }
              break;
              /* elm: sym */
              case 6: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_ELM;
                stack->continue_at_ = 24;
                {
                  {
  (stack->stack_[1].v_.uv0_) = (stack->sym_data_[0].v_.uv0_);
}
                }
                C24:;
              }
              break;
              /* elm: sym ASTERISK */
              case 7: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_ELM;
                stack->continue_at_ = 25;
                {
                  {
  size_t i, f;
  i = rex_nfa_make_node(nfa);
  f = rex_nfa_make_node(nfa);
  rex_nfa_make_empty_trans(nfa, i, f);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, (stack->sym_data_[0].v_.uv0_).initial_);
  rex_nfa_make_empty_trans(nfa, i, (stack->sym_data_[0].v_.uv0_).initial_);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, f);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C25:;
              }
              break;
              /* elm: sym PLUS */
              case 8: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_ELM;
                stack->continue_at_ = 26;
                {
                  {
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, f);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, (stack->sym_data_[0].v_.uv0_).initial_);
  (stack->stack_[1].v_.uv0_).initial_ = (stack->sym_data_[0].v_.uv0_).initial_;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C26:;
              }
              break;
              /* elm: sym QUESTION_MARK */
              case 9: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_ELM;
                stack->continue_at_ = 27;
                {
                  {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_empty_trans(nfa, i, f);
  rex_nfa_make_empty_trans(nfa, i, (stack->sym_data_[0].v_.uv0_).initial_);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, f);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C27:;
              }
              break;
              /* sym: CHAR */
              case 10: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_SYM;
                stack->continue_at_ = 28;
                {
                  {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_trans(nfa, i, f, (stack->sym_data_[0].v_.uv1_));
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C28:;
              }
              break;
              /* sym: CATEGORY */
              case 11: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_SYM;
                stack->continue_at_ = 29;
                {
                  {
  struct rex_set_range range;
  rex_set_range_init(&range);
  if (rex_set_range_unicode(&range, (stack->sym_data_[0].v_.uv2_).first_, (stack->sym_data_[0].v_.uv2_).last_, (stack->sym_data_[0].v_.uv2_).is_inverted_)) {
    rex_set_range_cleanup(&range);
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }

  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  size_t n;
  for (n = 0; n < range.num_intervals_; ++n) {
    rex_nfa_make_ranged_trans(nfa, i, f, range.intervals_[n].from_, range.intervals_[n].to_);
  }
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C29:;
              }
              break;
              /* sym: DOT */
              case 12: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_SYM;
                stack->continue_at_ = 30;
                {
                  {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_ranged_trans(nfa, i, f, 0, 0x9);
  /* omit 0xA LF */
  rex_nfa_make_ranged_trans(nfa, i, f, 0xB, 0xC);
  /* omit 0xD CR */
  rex_nfa_make_ranged_trans(nfa, i, f, 0xE, 0x84);
  /* omit 0x85 NEL */
  rex_nfa_make_ranged_trans(nfa, i, f, 0x86, 0x2027);
  /* omit 0x2028 Line Separator */
  /* omit 0x2029 Paragraph Separator */
  rex_nfa_make_ranged_trans(nfa, i, f, 0x2029, 0x10FFFF);
  
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C30:;
              }
              break;
              /* sym: CARET */
              case 13: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_SYM;
                stack->continue_at_ = 31;
                {
                  {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_anchor_trans(nfa, i, f, REX_ANCHOR_START_OF_LINE);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C31:;
              }
              break;
              /* sym: DOLLAR */
              case 14: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_SYM;
                stack->continue_at_ = 32;
                {
                  {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_anchor_trans(nfa, i, f, REX_ANCHOR_END_OF_LINE);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C32:;
              }
              break;
              /* sym: START_OF_INPUT_ESC */
              case 15: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_SYM;
                stack->continue_at_ = 33;
                {
                  {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_anchor_trans(nfa, i, f, REX_ANCHOR_START_OF_INPUT);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C33:;
              }
              break;
              /* sym: END_OF_INPUT_ESC */
              case 16: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_SYM;
                stack->continue_at_ = 34;
                {
                  {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_anchor_trans(nfa, i, f, REX_ANCHOR_END_OF_INPUT);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C34:;
              }
              break;
              /* sym: PAR_OPEN exp PAR_CLOSE */
              case 17: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_SYM;
                stack->continue_at_ = 35;
                {
                  { (stack->stack_[1].v_.uv0_) = (stack->sym_data_[1].v_.uv0_); }
                }
                C35:;
              }
              break;
              /* sym: SQBRACE_OPEN range SQBRACE_CLOSE */
              case 18: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_SYM;
                stack->continue_at_ = 36;
                {
                  {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  size_t n;
  for (n = 0; n < (stack->sym_data_[1].v_.uv3_).num_intervals_; ++n) {
    rex_nfa_make_ranged_trans(nfa, i, f, (stack->sym_data_[1].v_.uv3_).intervals_[n].from_, (stack->sym_data_[1].v_.uv3_).intervals_[n].to_);
  }
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C36:;
              }
              break;
              /* sym: SQBRACE_OPEN CARET range SQBRACE_CLOSE */
              case 19: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_SYM;
                stack->continue_at_ = 37;
                {
                  {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  size_t n;
  if (rex_set_range_unicode_invert(&(stack->sym_data_[2].v_.uv3_))) {
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }
  for (n = 0; n < (stack->sym_data_[2].v_.uv3_).num_intervals_; ++n) {
    rex_nfa_make_ranged_trans(nfa, i, f, (uint32_t)(stack->sym_data_[2].v_.uv3_).intervals_[n].from_, (uint32_t)(stack->sym_data_[2].v_.uv3_).intervals_[n].to_);
  }

  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
                }
                C37:;
              }
              break;
              /* range: range range-elm */
              case 20: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_RANGE;
                stack->continue_at_ = 38;
                {
                   rex_set_range_init(&(stack->stack_[1].v_.uv3_));
                }
                C38:;
                stack->continue_at_ = 39;
                {
                  {
  rex_set_range_swap(&(stack->stack_[1].v_.uv3_), &(stack->sym_data_[0].v_.uv3_));
  if (rex_set_range_add_range(&(stack->stack_[1].v_.uv3_), &(stack->sym_data_[1].v_.uv3_))) {
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }
}
                }
                C39:;
              }
              break;
              /* range: range-elm */
              case 21: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_RANGE;
                stack->continue_at_ = 40;
                {
                   rex_set_range_init(&(stack->stack_[1].v_.uv3_));
                }
                C40:;
                stack->continue_at_ = 41;
                {
                  {
  rex_set_range_swap(&(stack->stack_[1].v_.uv3_), &(stack->sym_data_[0].v_.uv3_));
}
                }
                C41:;
              }
              break;
              /* range-elm: CHAR */
              case 22: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_RANGE_ELM;
                stack->continue_at_ = 42;
                {
                   rex_set_range_init(&(stack->stack_[1].v_.uv3_));
                }
                C42:;
                stack->continue_at_ = 43;
                {
                  {
  if (rex_set_range_add(&(stack->stack_[1].v_.uv3_), (int)(stack->sym_data_[0].v_.uv1_), (int)(stack->sym_data_[0].v_.uv1_))) {
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }
}
                }
                C43:;
              }
              break;
              /* range-elm: CATEGORY */
              case 23: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_RANGE_ELM;
                stack->continue_at_ = 44;
                {
                   rex_set_range_init(&(stack->stack_[1].v_.uv3_));
                }
                C44:;
                stack->continue_at_ = 45;
                {
                  {
  if (rex_set_range_unicode(&(stack->stack_[1].v_.uv3_), (stack->sym_data_[0].v_.uv2_).first_, (stack->sym_data_[0].v_.uv2_).last_, (stack->sym_data_[0].v_.uv2_).is_inverted_)) {
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }
}
                }
                C45:;
              }
              break;
              /* range-elm: CHAR DASH CHAR */
              case 24: {
                stack->slot_1_has_sym_data_ = 1;
                stack->slot_1_sym_ = REX_RANGE_ELM;
                stack->continue_at_ = 46;
                {
                   rex_set_range_init(&(stack->stack_[1].v_.uv3_));
                }
                C46:;
                stack->continue_at_ = 47;
                {
                  {
  int from, to;
  if ((stack->sym_data_[0].v_.uv1_) < (stack->sym_data_[2].v_.uv1_)) {
    from = (int)(stack->sym_data_[0].v_.uv1_);
    to = (int)(stack->sym_data_[2].v_.uv1_);
  } else {
    from = (int)(stack->sym_data_[2].v_.uv1_);
    to = (int)(stack->sym_data_[0].v_.uv1_);
  }
  if (rex_set_range_add(&(stack->stack_[1].v_.uv3_), from, to)) {
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }
}
                }
                C47:;
              }
              break;
            } /* switch */
          } /* scope guard */
          
          /* Free symdata for every symbol in the production, including the first slot where we will soon
          * push nonterminal_data_reduced_to */
          size_t rex_sym_idx;
          for (rex_sym_idx = stack->pos_ - stack->current_production_length_; rex_sym_idx < stack->pos_; ++rex_sym_idx) {
            switch (stack->stack_[rex_sym_idx].state_) {
              case 21: /* range */
              case 23: /* range-elm */
              case 24: /* range */
              case 25: /* range-elm */
              {
                stack->continue_at_ = 48;
                {
                   rex_set_range_cleanup(&((stack->stack_ + rex_sym_idx)->v_.uv3_));
                }
                C48:;
                
              }
              break;
            } /* switch */
          } /* for */
          stack->pos_ -= stack->current_production_length_;
          action = rex_parse_table[rex_num_columns * stack->stack_[stack->pos_ - 1].state_ + (stack->current_production_nonterminal_ - rex_minimum_sym)];
          if (action <= 0) {
            stack->continue_at_ = 0;
            /* Internal error */
            return _REX_INTERNAL_ERROR;
          }
          switch (rex_push_state(stack, action /* action for a "goto" shift is the ordinal */)) {
            case _REX_OVERFLOW: {
              stack->continue_at_ = 0;
              return _REX_OVERFLOW;
            }
            break;
            case _REX_NO_MEMORY: {
              stack->continue_at_ = 0;
              return _REX_NO_MEMORY;
            }
            break;
          } /* switch */
          struct rex_sym_data *sd = stack->stack_ + stack->pos_ - 1;
          *sd = stack->stack_[1];
          sd->state_ = action;
          stack->slot_1_has_common_data_ = 0;
          stack->slot_1_has_sym_data_ = 0;
          stack->top_of_stack_has_sym_data_ = 1;
          stack->top_of_stack_has_common_data_ = 1;
        } /* action < 0 */
        else /* action == 0 */ {
          /* check if we can recover using an error token. */
          size_t n;
          for (n = 0; n < stack->pos_; ++n) {
            int err_action = rex_parse_table[rex_num_columns * stack->stack_[n].state_ + (24 /* error token */ - rex_minimum_sym)];
            if (err_action > 0) {
              /* we can transition on the error token somewhere on the stack */
              break;
            }
          }
          if (n != stack->pos_) {
            /* Enter error-token recovery mode given that such a recovery is possible */
            stack->error_recovery_ = (n != stack->pos_);
          }
          else {
            if (sym != REX_INPUT_END) {
              /* Retain EOF but discard any other sym so we make progress */
              stack->need_sym_ = 1;
              /* Deconstruct placeholder location for discarded symbol */
              switch (stack->current_sym_) {
                case 27:
                case 28:
                case 29:
                case 30:
                break;
                case 19:
                break;
                case 20:
                break;
                case 32:
                case 31:
                stack->continue_at_ = 49;
                {
                   rex_set_range_cleanup(&(stack->stack_[0].v_.uv3_));
                }
                C49:;
                break;
              } /* switch */
            }
          }
          /* Issue the error here */
          if (!stack->mute_error_turns_) {
            stack->mute_error_turns_ = 3;
            stack->continue_at_ = 0;
            /* Syntax error */
            return _REX_SYNTAX_ERROR;
          }
          else {
            stack->mute_error_turns_--;
            if (sym == REX_INPUT_END) {
              /* EOF means we cannot shift to recover, and errors are muted, so return completion */
              stack->pending_reset_ = 1;
              return _REX_FINISH;
            }
          }
        }
      } /* !stack->error_recovery_ */
      if (stack->error_recovery_) {
        size_t n;
        n = stack->pos_;
        if (n) {
          do {
            --n;
            /* Can we shift an error token? */
            int err_action = rex_parse_table[rex_num_columns * stack->stack_[n].state_ + (24 /* error token */ - rex_minimum_sym)];
            if (err_action > 0) {
              /* Does the resulting state accept the current symbol? */
              int err_sym_action = rex_parse_table[rex_num_columns * err_action + (sym - rex_minimum_sym)];
              if (err_sym_action) {
                /* Current symbol is accepted, recover error condition by shifting the error token and then process the symbol as usual */
                /* Free symdata for every symbol up to the state where we will shift the error token */
                size_t rex_sym_idx;
                for (rex_sym_idx = n + 1; rex_sym_idx < stack->pos_; ++rex_sym_idx) {
                  switch (stack->stack_[rex_sym_idx].state_) {
                    case 21: /* range */
                    case 23: /* range-elm */
                    case 24: /* range */
                    case 25: /* range-elm */
                    stack->continue_at_ = 50;
                    {
                       rex_set_range_cleanup(&((stack->stack_ + rex_sym_idx)->v_.uv3_));
                    }
                    C50:;
                    break;
                  } /* switch */
                } /* for */
                stack->pos_ = n + 1;
                switch (rex_push_state(stack, err_action)) {
                  case _REX_OVERFLOW: {
                    stack->continue_at_ = 0;
                    return _REX_OVERFLOW;
                  }
                  break;
                  case _REX_NO_MEMORY: {
                    stack->continue_at_ = 0;
                    return _REX_NO_MEMORY;
                  }
                  break;
                } /* switch */
                stack->error_recovery_ = 0;
                /* Break out of do { .. } while loop, we've recovered */
                break;
              } /* if (err_sym_action) (if the current sym can continue after an error transition) */
            } /* if (err_action) (if the state at position 'n' can accept an error transition) */
          } while (n);
        }
        if (stack->error_recovery_) {
          /* Did not yet recover, discard current sym and get next */
          if (stack->current_sym_ == REX_INPUT_END) {
            /* EOF means we cannot shift to recover, so return completion */
            stack->pending_reset_ = 1;
            return _REX_FINISH;
          }
          stack->need_sym_ = 1;
          /* Deconstruct placeholder location for discarded symbol */
          switch (stack->current_sym_) {
            case 27:
            case 28:
            case 29:
            case 30:
            break;
            case 19:
            break;
            case 20:
            break;
            case 32:
            case 31:
            stack->continue_at_ = 51;
            {
               rex_set_range_cleanup(&(stack->stack_[0].v_.uv3_));
            }
            C51:;
            break;
          } /* switch */
        }
      } /* stack->error_recovery_ */
    }
  } /* for (;;) */
}

int rex_parse(struct rex_stack *stack, int sym, struct rex_nfa *nfa, size_t *pstart, size_t *pend) {
  if (stack->pending_reset_) {
    int r;
    r = rex_stack_reset(stack);
    if (r) return r;
  }
    switch (stack->continue_at_) {
    case 0: break; /* fall through to regular code path */
    case 1: goto C1;
    case 2: goto C2;
    case 3: goto C3;
    case 4: goto C4;
    case 5: goto C5;
    case 6: goto C6;
    case 7: goto C7;
    case 8: goto C8;
    case 9: goto C9;
    case 10: goto C10;
    case 11: goto C11;
    case 12: goto C12;
    case 13: goto C13;
    case 14: goto C14;
    case 15: goto C15;
    case 16: goto C16;
    case 17: goto C17;
    case 18: goto C18;
    case 19: goto C19;
    case 20: goto C20;
    case 21: goto C21;
    case 22: goto C22;
    case 23: goto C23;
    case 24: goto C24;
    case 25: goto C25;
    case 26: goto C26;
    case 27: goto C27;
    case 28: goto C28;
    case 29: goto C29;
    case 30: goto C30;
    case 31: goto C31;
  } /* continuation switch */
if (stack->mute_error_turns_) stack->mute_error_turns_--;
  for (;;) {
    if (!stack->error_recovery_) {
      int action = rex_parse_table[rex_num_columns * stack->stack_[stack->pos_ - 1].state_ + (sym - rex_minimum_sym)];
      if (action > 0) {
        switch (rex_push_state(stack, action)) {
          case _REX_OVERFLOW: {
            stack->continue_at_ = 0;
            return _REX_OVERFLOW;
          }
          break;
          case _REX_NO_MEMORY: {
            stack->continue_at_ = 0;
            return _REX_NO_MEMORY;
          }
          break;
        } /* switch */
        
        stack->sym_data_ = stack->stack_ + stack->pos_ - 1;
        stack->top_of_stack_has_sym_data_ = 0;
        switch (sym) {
          case REX_CHAR:
          stack->top_of_stack_has_sym_data_ = 1;
          break;
          case REX_CATEGORY:
          stack->top_of_stack_has_sym_data_ = 1;
          break;
        } /* switch */
        stack->continue_at_ = 0;
        /* Next token */
        return _REX_FEED_ME;
      } /* action > 0 */
      else if (action < 0) {
        int production = -action - 1;
        stack->discard_remaining_actions_ = 0;
        stack->current_production_length_ = rex_production_lengths[production];
        stack->current_production_nonterminal_ = rex_production_syms[production];
        if (0 == production) {
          stack->pending_reset_ = 1;
          /* Synth S we're done */
          return _REX_FINISH;
        }
        
        memset(&stack->stack_[1], 0, sizeof(struct rex_sym_data));
        { /* scope guard */
          stack->sym_data_ = stack->stack_ + stack->pos_ - stack->current_production_length_;
          switch (production) {
            /* regex: exp */
            case 1: {
              stack->continue_at_ = 1;
              {
                {
  *pstart = (stack->sym_data_[0].v_.uv0_).initial_;
  *pend = (stack->sym_data_[0].v_.uv0_).final_;
}
              }
              C1:;
            }
            break;
            /* exp: term */
            case 2: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_EXP;
              stack->continue_at_ = 2;
              {
                { 
  (stack->stack_[1].v_.uv0_) = (stack->sym_data_[0].v_.uv0_); 
}
              }
              C2:;
            }
            break;
            /* exp: exp BAR term */
            case 3: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_EXP;
              stack->continue_at_ = 3;
              {
                {
  size_t i, f;
  i = rex_nfa_make_node(nfa);
  f = rex_nfa_make_node(nfa);
  rex_nfa_make_empty_trans(nfa, i, (stack->sym_data_[0].v_.uv0_).initial_);
  rex_nfa_make_empty_trans(nfa, i, (stack->sym_data_[2].v_.uv0_).initial_);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, f);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[2].v_.uv0_).final_, f);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C3:;
            }
            break;
            /* term: */
            case 4: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_TERM;
              stack->continue_at_ = 4;
              {
                {
  (stack->stack_[1].v_.uv0_).initial_ = rex_nfa_make_node(nfa);
  (stack->stack_[1].v_.uv0_).final_ = rex_nfa_make_node(nfa);
  rex_nfa_make_empty_trans(nfa, (stack->stack_[1].v_.uv0_).initial_, (stack->stack_[1].v_.uv0_).final_);
}
              }
              C4:;
            }
            break;
            /* term: term elm */
            case 5: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_TERM;
              stack->continue_at_ = 5;
              {
                {
  (stack->stack_[1].v_.uv0_).initial_ = (stack->sym_data_[0].v_.uv0_).initial_;
  (stack->stack_[1].v_.uv0_).final_ = (stack->sym_data_[1].v_.uv0_).final_;
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, (stack->sym_data_[1].v_.uv0_).initial_);
}
              }
              C5:;
            }
            break;
            /* elm: sym */
            case 6: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_ELM;
              stack->continue_at_ = 6;
              {
                {
  (stack->stack_[1].v_.uv0_) = (stack->sym_data_[0].v_.uv0_);
}
              }
              C6:;
            }
            break;
            /* elm: sym ASTERISK */
            case 7: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_ELM;
              stack->continue_at_ = 7;
              {
                {
  size_t i, f;
  i = rex_nfa_make_node(nfa);
  f = rex_nfa_make_node(nfa);
  rex_nfa_make_empty_trans(nfa, i, f);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, (stack->sym_data_[0].v_.uv0_).initial_);
  rex_nfa_make_empty_trans(nfa, i, (stack->sym_data_[0].v_.uv0_).initial_);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, f);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C7:;
            }
            break;
            /* elm: sym PLUS */
            case 8: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_ELM;
              stack->continue_at_ = 8;
              {
                {
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, f);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, (stack->sym_data_[0].v_.uv0_).initial_);
  (stack->stack_[1].v_.uv0_).initial_ = (stack->sym_data_[0].v_.uv0_).initial_;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C8:;
            }
            break;
            /* elm: sym QUESTION_MARK */
            case 9: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_ELM;
              stack->continue_at_ = 9;
              {
                {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_empty_trans(nfa, i, f);
  rex_nfa_make_empty_trans(nfa, i, (stack->sym_data_[0].v_.uv0_).initial_);
  rex_nfa_make_empty_trans(nfa, (stack->sym_data_[0].v_.uv0_).final_, f);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C9:;
            }
            break;
            /* sym: CHAR */
            case 10: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_SYM;
              stack->continue_at_ = 10;
              {
                {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_trans(nfa, i, f, (stack->sym_data_[0].v_.uv1_));
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C10:;
            }
            break;
            /* sym: CATEGORY */
            case 11: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_SYM;
              stack->continue_at_ = 11;
              {
                {
  struct rex_set_range range;
  rex_set_range_init(&range);
  if (rex_set_range_unicode(&range, (stack->sym_data_[0].v_.uv2_).first_, (stack->sym_data_[0].v_.uv2_).last_, (stack->sym_data_[0].v_.uv2_).is_inverted_)) {
    rex_set_range_cleanup(&range);
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }

  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  size_t n;
  for (n = 0; n < range.num_intervals_; ++n) {
    rex_nfa_make_ranged_trans(nfa, i, f, range.intervals_[n].from_, range.intervals_[n].to_);
  }
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C11:;
            }
            break;
            /* sym: DOT */
            case 12: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_SYM;
              stack->continue_at_ = 12;
              {
                {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_ranged_trans(nfa, i, f, 0, 0x9);
  /* omit 0xA LF */
  rex_nfa_make_ranged_trans(nfa, i, f, 0xB, 0xC);
  /* omit 0xD CR */
  rex_nfa_make_ranged_trans(nfa, i, f, 0xE, 0x84);
  /* omit 0x85 NEL */
  rex_nfa_make_ranged_trans(nfa, i, f, 0x86, 0x2027);
  /* omit 0x2028 Line Separator */
  /* omit 0x2029 Paragraph Separator */
  rex_nfa_make_ranged_trans(nfa, i, f, 0x2029, 0x10FFFF);
  
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C12:;
            }
            break;
            /* sym: CARET */
            case 13: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_SYM;
              stack->continue_at_ = 13;
              {
                {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_anchor_trans(nfa, i, f, REX_ANCHOR_START_OF_LINE);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C13:;
            }
            break;
            /* sym: DOLLAR */
            case 14: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_SYM;
              stack->continue_at_ = 14;
              {
                {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_anchor_trans(nfa, i, f, REX_ANCHOR_END_OF_LINE);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C14:;
            }
            break;
            /* sym: START_OF_INPUT_ESC */
            case 15: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_SYM;
              stack->continue_at_ = 15;
              {
                {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_anchor_trans(nfa, i, f, REX_ANCHOR_START_OF_INPUT);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C15:;
            }
            break;
            /* sym: END_OF_INPUT_ESC */
            case 16: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_SYM;
              stack->continue_at_ = 16;
              {
                {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  rex_nfa_make_anchor_trans(nfa, i, f, REX_ANCHOR_END_OF_INPUT);
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C16:;
            }
            break;
            /* sym: PAR_OPEN exp PAR_CLOSE */
            case 17: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_SYM;
              stack->continue_at_ = 17;
              {
                { (stack->stack_[1].v_.uv0_) = (stack->sym_data_[1].v_.uv0_); }
              }
              C17:;
            }
            break;
            /* sym: SQBRACE_OPEN range SQBRACE_CLOSE */
            case 18: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_SYM;
              stack->continue_at_ = 18;
              {
                {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  size_t n;
  for (n = 0; n < (stack->sym_data_[1].v_.uv3_).num_intervals_; ++n) {
    rex_nfa_make_ranged_trans(nfa, i, f, (stack->sym_data_[1].v_.uv3_).intervals_[n].from_, (stack->sym_data_[1].v_.uv3_).intervals_[n].to_);
  }
  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C18:;
            }
            break;
            /* sym: SQBRACE_OPEN CARET range SQBRACE_CLOSE */
            case 19: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_SYM;
              stack->continue_at_ = 19;
              {
                {
  size_t i = rex_nfa_make_node(nfa);
  size_t f = rex_nfa_make_node(nfa);
  size_t n;
  if (rex_set_range_unicode_invert(&(stack->sym_data_[2].v_.uv3_))) {
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }
  for (n = 0; n < (stack->sym_data_[2].v_.uv3_).num_intervals_; ++n) {
    rex_nfa_make_ranged_trans(nfa, i, f, (uint32_t)(stack->sym_data_[2].v_.uv3_).intervals_[n].from_, (uint32_t)(stack->sym_data_[2].v_.uv3_).intervals_[n].to_);
  }

  (stack->stack_[1].v_.uv0_).initial_ = i;
  (stack->stack_[1].v_.uv0_).final_ = f;
}
              }
              C19:;
            }
            break;
            /* range: range range-elm */
            case 20: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_RANGE;
              stack->continue_at_ = 20;
              {
                 rex_set_range_init(&(stack->stack_[1].v_.uv3_));
              }
              C20:;
              stack->continue_at_ = 21;
              {
                {
  rex_set_range_swap(&(stack->stack_[1].v_.uv3_), &(stack->sym_data_[0].v_.uv3_));
  if (rex_set_range_add_range(&(stack->stack_[1].v_.uv3_), &(stack->sym_data_[1].v_.uv3_))) {
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }
}
              }
              C21:;
            }
            break;
            /* range: range-elm */
            case 21: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_RANGE;
              stack->continue_at_ = 22;
              {
                 rex_set_range_init(&(stack->stack_[1].v_.uv3_));
              }
              C22:;
              stack->continue_at_ = 23;
              {
                {
  rex_set_range_swap(&(stack->stack_[1].v_.uv3_), &(stack->sym_data_[0].v_.uv3_));
}
              }
              C23:;
            }
            break;
            /* range-elm: CHAR */
            case 22: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_RANGE_ELM;
              stack->continue_at_ = 24;
              {
                 rex_set_range_init(&(stack->stack_[1].v_.uv3_));
              }
              C24:;
              stack->continue_at_ = 25;
              {
                {
  if (rex_set_range_add(&(stack->stack_[1].v_.uv3_), (int)(stack->sym_data_[0].v_.uv1_), (int)(stack->sym_data_[0].v_.uv1_))) {
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }
}
              }
              C25:;
            }
            break;
            /* range-elm: CATEGORY */
            case 23: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_RANGE_ELM;
              stack->continue_at_ = 26;
              {
                 rex_set_range_init(&(stack->stack_[1].v_.uv3_));
              }
              C26:;
              stack->continue_at_ = 27;
              {
                {
  if (rex_set_range_unicode(&(stack->stack_[1].v_.uv3_), (stack->sym_data_[0].v_.uv2_).first_, (stack->sym_data_[0].v_.uv2_).last_, (stack->sym_data_[0].v_.uv2_).is_inverted_)) {
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }
}
              }
              C27:;
            }
            break;
            /* range-elm: CHAR DASH CHAR */
            case 24: {
              stack->slot_1_has_sym_data_ = 1;
              stack->slot_1_sym_ = REX_RANGE_ELM;
              stack->continue_at_ = 28;
              {
                 rex_set_range_init(&(stack->stack_[1].v_.uv3_));
              }
              C28:;
              stack->continue_at_ = 29;
              {
                {
  int from, to;
  if ((stack->sym_data_[0].v_.uv1_) < (stack->sym_data_[2].v_.uv1_)) {
    from = (int)(stack->sym_data_[0].v_.uv1_);
    to = (int)(stack->sym_data_[2].v_.uv1_);
  } else {
    from = (int)(stack->sym_data_[2].v_.uv1_);
    to = (int)(stack->sym_data_[0].v_.uv1_);
  }
  if (rex_set_range_add(&(stack->stack_[1].v_.uv3_), from, to)) {
    nfa->failed_ = _REX_NO_MEMORY;
    return _REX_NO_MEMORY;
  }
}
              }
              C29:;
            }
            break;
          } /* switch */
        } /* scope guard */
        
        /* Free symdata for every symbol in the production, including the first slot where we will soon
        * push nonterminal_data_reduced_to */
        size_t rex_sym_idx;
        for (rex_sym_idx = stack->pos_ - stack->current_production_length_; rex_sym_idx < stack->pos_; ++rex_sym_idx) {
          switch (stack->stack_[rex_sym_idx].state_) {
            case 21: /* range */
            case 23: /* range-elm */
            case 24: /* range */
            case 25: /* range-elm */
            stack->continue_at_ = 30;
            {
               rex_set_range_cleanup(&((stack->stack_ + rex_sym_idx)->v_.uv3_));
            }
            C30:;
            break;
          } /* switch */
        } /* for */
        stack->pos_ -= stack->current_production_length_;
        action = rex_parse_table[rex_num_columns * stack->stack_[stack->pos_ - 1].state_ + (stack->current_production_nonterminal_ - rex_minimum_sym)];
        if (action <= 0) {
          stack->continue_at_ = 0;
          /* Internal error */
          return _REX_INTERNAL_ERROR;
        }
        switch (rex_push_state(stack, action /* action for a "goto" shift is the ordinal */)) {
          case _REX_OVERFLOW: {
            stack->continue_at_ = 0;
            return _REX_OVERFLOW;
          }
          break;
          case _REX_NO_MEMORY: {
            stack->continue_at_ = 0;
            return _REX_NO_MEMORY;
          }
          break;
        } /* switch */
        struct rex_sym_data *sd = stack->stack_ + stack->pos_ - 1;
        *sd = stack->stack_[1];
        sd->state_ = action;
        stack->slot_1_has_common_data_ = 0;
        stack->slot_1_has_sym_data_ = 0;
        stack->top_of_stack_has_common_data_ = 1;
        stack->top_of_stack_has_sym_data_ = 1;
      } /* action < 0 */
      else /* action == 0 */ {
        /* check if we can recover using an error token. */
        size_t n;
        for (n = 0; n < stack->pos_; ++n) {
          int err_action = rex_parse_table[rex_num_columns * stack->stack_[n].state_ + (24 /* error token */ - rex_minimum_sym)];
          if (err_action > 0) {
            /* we can transition on the error token somewhere on the stack */
            break;
          }
        }
        /* Enter error-token recovery mode given that such a recovery is possible */
        stack->error_recovery_ = (n != stack->pos_);
        /* Issue the error here */
        if (!stack->mute_error_turns_) {
          stack->mute_error_turns_ = 3;
          stack->continue_at_ = 0;
          /* Syntax error */
          return _REX_SYNTAX_ERROR;
        }
        else {
          stack->mute_error_turns_--;
          if (sym == REX_INPUT_END) {
            /* EOF means we cannot shift to recover, and errors are muted, so return completion */
            stack->pending_reset_ = 1;
            return _REX_FINISH;
          }
          /* Retain EOF but discard any other sym so we make progress */
          stack->continue_at_ = 0;
          /* Next token */
          return _REX_FEED_ME;
        }
      }
    } /* !stack->error_recovery_ */
    if (stack->error_recovery_) {
      size_t n;
      n = stack->pos_;
      if (n) {
        do {
          --n;
          /* Can we shift an error token? */
          int err_action = rex_parse_table[rex_num_columns * stack->stack_[n].state_ + (24 /* error token */ - rex_minimum_sym)];
          if (err_action > 0) {
            /* Does the resulting state accept the current symbol? */
            int err_sym_action = rex_parse_table[rex_num_columns * err_action + (sym - rex_minimum_sym)];
            if (err_sym_action) {
              /* Current symbol is accepted, recover error condition by shifting the error token and then process the symbol as usual */
              /* Free symdata for every symbol up to the state where we will shift the error token */
              size_t rex_sym_idx;
              for (rex_sym_idx = n + 1; rex_sym_idx < stack->pos_; ++rex_sym_idx) {
                switch (stack->stack_[rex_sym_idx].state_) {
                  case 21: /* range */
                  case 23: /* range-elm */
                  case 24: /* range */
                  case 25: /* range-elm */
                  stack->continue_at_ = 31;
                  {
                     rex_set_range_cleanup(&((stack->stack_ + rex_sym_idx)->v_.uv3_));
                  }
                  C31:;
                  break;
                } /* switch */
              } /* for */
              stack->pos_ = n + 1;
              /* Push the state of the error transition */
              switch (rex_push_state(stack, err_action)) {
                case _REX_OVERFLOW: {
                  stack->continue_at_ = 0;
                  return _REX_OVERFLOW;
                }
                break;
                case _REX_NO_MEMORY: {
                  stack->continue_at_ = 0;
                  return _REX_NO_MEMORY;
                }
                break;
              } /* switch */
              stack->error_recovery_ = 0;
              /* Break out of do { .. } while loop, we've recovered */
              break;
            } /* if (err_sym_action) (if the current sym can continue after an error transition) */
          } /* if (err_action) (if the state at position 'n' can accept an error transition) */
        } while (n);
      }
      if (stack->error_recovery_) {
        /* Did not yet recover, discard current sym and get next */
        if (sym == REX_INPUT_END) {
          /* EOF means we cannot shift to recover, so return completion */
          stack->pending_reset_ = 1;
          return _REX_FINISH;
        }
        stack->continue_at_ = 0;
        /* Next token */
        return _REX_FEED_ME;
      }
    } /* stack->error_recovery_ */
  } /* for (;;) */
}
/* --------- END OF GENERATED CODE ------------ */

