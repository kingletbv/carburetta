#ifndef STDIO_H_INCLUDED
#define STDIO_H_INCLUDED
#include <stdio.h>
#endif

#ifndef STDLIB_H_INCLUDED
#define STDLIB_H_INCLUDED
#include <stdlib.h>
#endif

#ifndef STDINT_H_INCLUDED
#define STDINT_H_INCLUDED
#include <stdint.h>
#endif

#ifndef STRING_H_INCLUDED
#define STRING_H_INCLUDED
#include <string.h>
#endif

#ifndef ERRNO_H_INCLUDED
#define ERNNO_H_INCLUDED
#include <errno.h>
#endif

#ifndef ASSERT_H_INCLUDED
#define ASSERT_H_INCLUDED
#include <assert.h>
#endif

#ifndef TOKENIZER_H_INCLUDED
#define TOKENIZER_H_INCLUDED
#include "tokenizer.h"
#endif

#ifndef TOKENS_H_INCLUDED
#define TOKENS_H_INCLUDED
#include "tokens.h"
#endif

#ifndef KLT_LOGGER_H_INCLUDED
#define KLT_LOGGER_H_INCLUDED
#define KLT_LOG_MODULE "prd"
#include "klt_logger.h"
#endif

#ifndef REPORT_ERROR_H_INCLUDED
#define REPORT_ERROR_H_INCLUDED
#include "report_error.h"
#endif

#ifndef PRD_GRAM_H_INCLUDED
#define PRD_GRAM_H_INCLUDED
#include "prd_gram.h"
#endif

static void prd_production_sym_init(struct prd_production_sym *pps) {
  xlts_init(&pps->id_);
  pps->sym_ = NULL;
}

static void prd_production_sym_cleanup(struct prd_production_sym *pps) {
  xlts_cleanup(&pps->id_);
}

static void prd_prod_init(struct prd_production *ppd) {
  prd_production_sym_init(&ppd->nt_);
  ppd->num_syms_ = ppd->num_syms_allocated_ = 0;
  ppd->syms_ = NULL;
  snippet_init(&ppd->action_sequence_);
}

static void prd_prod_cleanup(struct prd_production *ppd) {
  size_t n;
  prd_production_sym_cleanup(&ppd->nt_);
  if (ppd->syms_) {
    for (n = 0; n < ppd->num_syms_; ++n) {
      prd_production_sym_cleanup(ppd->syms_ + n);
    }
    free(ppd->syms_);
  }
  snippet_cleanup(&ppd->action_sequence_);
}

void prd_grammar_init(struct prd_grammar *g) {
  g->have_errors_ = 0;
  g->accept_whitespace_ = 0;
  g->num_productions_ = g->num_productions_allocated_ = 0;
  g->productions_ = NULL;
}

void prd_grammar_cleanup(struct prd_grammar *g) {
  size_t n;

  for (n = 0; n < g->num_productions_; ++n) {
    prd_prod_cleanup(g->productions_ + n);
  }
  if (g->productions_) free(g->productions_);
}

void prd_prod_swap(struct prd_production *a, struct prd_production *b) {
  struct prd_production swap;
  swap = *a;
  *a = *b;
  *b = swap;
}

static int prd_grammar_check_production_reserve(struct prd_grammar *g) {
  if (g->num_productions_ == g->num_productions_allocated_) {
    size_t new_num = g->num_productions_allocated_ * 2 + 1;
    if (new_num < 7) new_num = 7;
    if (new_num <= g->num_productions_allocated_) {
      LOGERROR("Internal error, overflow on allocation");
      return PRD_INTERNAL_ERROR;
    }
    if (new_num > (SIZE_MAX / sizeof(struct prd_production))) {
      LOGERROR("Internal error, overflow on allocation");
      return PRD_INTERNAL_ERROR;
    }
    size_t size_to_alloc = new_num * sizeof(struct prd_production);
    void *p = realloc(g->productions_, size_to_alloc);
    if (!p) {
      LOGERROR("Internal error, no memory");
      return PRD_INTERNAL_ERROR;
    }
    g->productions_ = (struct prd_production *)p;
    g->num_productions_allocated_ = new_num;
  }

  return 0;
}

static int prd_prod_check_sym_reserve(struct prd_production *pd, struct xlts *loc) {
  if (pd->num_syms_ == pd->num_syms_allocated_) {
    size_t new_num = pd->num_syms_allocated_ * 2 + 1;
    if (new_num < 7) new_num = 7;
    if (new_num <= pd->num_syms_allocated_) {
      re_error(loc, "Internal error, overflow on allocation");
      return PRD_INTERNAL_ERROR;
    }
    if (new_num > (SIZE_MAX / sizeof(struct prd_production_sym))) {
      re_error(loc, "Internal error, overflow on allocation");
      return PRD_INTERNAL_ERROR;
    }
    size_t size_to_alloc = new_num * sizeof(struct prd_production_sym);
    void *p = realloc(pd->syms_, size_to_alloc);
    if (!p) {
      re_error(loc, "Internal error, no memory");
      return PRD_INTERNAL_ERROR;
    }
    pd->syms_ = (struct prd_production_sym *)p;
    pd->num_syms_allocated_ = new_num;
  }
  return 0;
}

%prefix prd_

%token ident colon equals semicolon token par-open par-close cubrace-open cubrace-close
%nt grammar rule production action-sequence stmt-action start-c-tokenizer end-c-tokenizer accept-whitespace

%token_type struct { \
  token_type_t match_; \
  token_type_t variant_; \
  struct xlts text_; \
}
%constructor $$.match_ = $$.variant_ = 0; \
             xlts_init(&$$.text_);
%destructor xlts_cleanup(&$$.text_);

%token_action $$.match_ = tkr->best_match_action_; \
              $$.variant_ = tkr->best_match_variant_; \
			  xlts_append(&$$.text_, &tkr->xmatch_);

%nt_type rule production action-sequence stmt-action: struct prd_production
%constructor prd_prod_init(&$$);
%destructor prd_prod_cleanup(&$$);

%params struct prd_grammar *g, struct tkr_tokenizer *tkr, struct symbol_table *st
%locals int r; \
        struct prd_production *pd; \
        struct symbol *sym;


%%

grammar: { }
grammar: grammar production {
	/* Store the PRD_PRODUCTION in the prd_grammar->productions_ array */
	r = prd_grammar_check_production_reserve(g);
	if (r) return r;
	pd = g->productions_ + g->num_productions_++;
	prd_prod_init(pd);
	prd_prod_swap(pd, &$1);
}

production: IDENT COLON rule SEMICOLON {
	sym = symbol_find(st, $0.text_.translated_);
	if (!sym) {
		re_error(&$0.text_, "Error, symbol \"%s\" not declared as %%nt", $0.text_.translated_);
		g->have_errors_ = 1;
		return PRD_SUCCESS;
	}

	prd_prod_swap(&$$, &$2);
	pd = &$$;
	xlts_append(&pd->nt_.id_, &$0.text_);
	pd->nt_.sym_ = sym;
}
production: IDENT COLON rule start-c-tokenizer stmt-action end-c-tokenizer SEMICOLON {
	sym = symbol_find(st, $0.text_.translated_);
	if (!sym) {
		re_error(&$1.text_, "Error, symbol \"%s\" not declared as %%nt", $0.text_.translated_);
		g->have_errors_ = 1;
		return PRD_SUCCESS;
	}

	prd_prod_swap(&$$, &$2);
	pd = &$$;
	xlts_append(&pd->nt_.id_, &$0.text_);
	pd->nt_.sym_ = sym;

	/* Move snippets in; could do this more efficiently by manually swapping pointers; but this works.. */
	r = snippet_append_snippet(&pd->action_sequence_, & $4.action_sequence_);
	if (r) return r;

	/* Append the semicolon to the snippets */
	r = snippet_append(&pd->action_sequence_, $6.match_, $6.variant_, &$6.text_);
	if (r) return r;
}
production: IDENT COLON rule start-c-tokenizer accept-whitespace CUBRACE_OPEN action-sequence end-c-tokenizer CUBRACE_CLOSE {
	sym = symbol_find(st, $0.text_.translated_);
	if (!sym) {
		re_error(&$1.text_, "Error, symbol \"%s\" not declared as %%nt", $0.text_.translated_);
		g->have_errors_ = 1;
		return PRD_SUCCESS;
	}

	prd_prod_swap(&$$, &$2);
	pd = &$$;
	xlts_append(&pd->nt_.id_, &$0.text_);
	pd->nt_.sym_ = sym;

	/* Move snippets in; could do this more efficiently by manually swapping pointers; but this works.. */
	/* Append the cubrace-open to the snippets */
	r = snippet_append(&pd->action_sequence_, $5.match_, $5.variant_, &$5.text_);
	if (r) return r;

	/* Move snippets in; could do this more efficiently by manually swapping pointers; but this works.. */
	r = snippet_append_snippet(&pd->action_sequence_, &$6.action_sequence_);
	if (r) return r;

	/* Append the cubrace-close to the snippets */
	r = snippet_append(&pd->action_sequence_, $8.match_, $8.variant_, &$8.text_);
	if (r) return r;
}

rule: ; /* Default PRD_RULE reduction sym has empty initialized prod_ which works for us. */
rule: rule IDENT {
	/* Grab ident from position 1, reduce */
	sym = symbol_find(st, $1.text_.translated_);
	if (!sym) {
		re_error(&$1.text_, "Error, symbol \"%s\" not declared as %%nt or %%token", $1.text_.translated_);
		g->have_errors_ = 1;
		return PRD_SUCCESS;
	}
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	if (pd->num_syms_ == pd->num_syms_allocated_) {
		r = prd_prod_check_sym_reserve(pd, &$1.text_);
		if (r) return r;
	}
	struct prd_production_sym *pps = pd->syms_ + pd->num_syms_++;
	prd_production_sym_init(pps);
	r = xlts_append(&pps->id_, &$1.text_);
	if (r) return PRD_INTERNAL_ERROR;
	pps->sym_ = sym;
}

stmt-action: EQUALS accept-whitespace; /* Return vacuous prd_production */
stmt-action: stmt-action IDENT {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return PRD_INTERNAL_ERROR;
}
stmt-action: stmt-action COLON {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return PRD_INTERNAL_ERROR;
}
stmt-action: stmt-action EQUALS {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return PRD_INTERNAL_ERROR;
}
stmt-action: stmt-action TOKEN {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return PRD_INTERNAL_ERROR;
}
stmt-action: stmt-action PAR_OPEN action-sequence PAR_CLOSE {
	prd_prod_swap(&$$, &$0);
	pd = &$$;

	/* Append the par-open to the snippets */
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return r;

	/* Move snippets in; could do this more efficiently by manually swapping pointers; but this works.. */
	r = snippet_append_snippet(&pd->action_sequence_, &$2.action_sequence_);
	if (r) return r;

	/* Append the par-close to the snippets */
	r = snippet_append(&pd->action_sequence_, $3.match_, $3.variant_, &$3.text_);
	if (r) return r;
}
stmt-action: stmt-action CUBRACE_OPEN action-sequence CUBRACE_CLOSE {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	/* Append the cubrace-open to the snippets */
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return r;

	/* Move snippets in; could do this more efficiently by manually swapping pointers; but this works.. */
	r = snippet_append_snippet(&pd->action_sequence_, &$2.action_sequence_);
	if (r) return r;

	/* Append the cubrace-close to the snippets */
	r = snippet_append(&pd->action_sequence_, $3.match_, $3.variant_, &$3.text_);
	if (r) return r;
}

action-sequence: ; /* Return vacuous prd_production */
action-sequence: action-sequence IDENT {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return PRD_INTERNAL_ERROR;
}
action-sequence: action-sequence COLON {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return PRD_INTERNAL_ERROR;
}
action-sequence: action-sequence EQUALS {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return PRD_INTERNAL_ERROR;
}
action-sequence: action-sequence SEMICOLON {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return PRD_INTERNAL_ERROR;
}
action-sequence: action-sequence TOKEN {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return PRD_INTERNAL_ERROR;
}
action-sequence: action-sequence PAR_OPEN action-sequence PAR_CLOSE {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	/* Append the par-open to the snippets */
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return r;

	/* Move snippets in; could do this more efficiently by manually swapping pointers; but this works.. */
	r = snippet_append_snippet(&pd->action_sequence_, &$2.action_sequence_);
	if (r) return r;

	/* Append the par-close to the snippets */
	r = snippet_append(&pd->action_sequence_, $3.match_, $3.variant_, &$3.text_);
	if (r) return r;
}
action-sequence: action-sequence CUBRACE_OPEN action-sequence CUBRACE_CLOSE {
	prd_prod_swap(&$$, &$0);
	pd = &$$;
	/* Append the cubrace-open to the snippets */
	r = snippet_append(&pd->action_sequence_, $1.match_, $1.variant_, &$1.text_);
	if (r) return r;

	/* Move snippets in; could do this more efficiently by manually swapping pointers; but this works.. */
	r = snippet_append_snippet(&pd->action_sequence_, &$2.action_sequence_);
	if (r) return r;

	/* Append the cubrace-close to the snippets */
	r = snippet_append(&pd->action_sequence_, $3.match_, $3.variant_, &$3.text_);
	if (r) return r;
}

start-c-tokenizer: = tok_switch_to_c_idents(tkr);
end-c-tokenizer: {
	tok_switch_to_nonterminal_idents(tkr);
	g->accept_whitespace_ = 0; /* Reset to normal tokens */
}

accept-whitespace: {
	/* Welcome whitespace from this point. Note that this point is *after* the lookahead at the point
	 * that the PRD_ACCEPT_WHITESPACE non-terminal appears. Therefore, it is *after* the EQUALS sign and
	 * *after* the curly opening brace. */
	g->accept_whitespace_ = 1;
}


%%

int prd_parse(struct prd_stack *stack, struct prd_grammar *g, struct tkr_tokenizer *tkr, int end_of_input, struct symbol_table *st) {
  int sym;

  if (!end_of_input) {
    token_type_t tkt = (token_type_t)tkr->best_match_variant_;
    if (!g->accept_whitespace_ && (tkt == TOK_WHITESPACE)) {
      /* Eat whitespace */
      return PRD_NEXT;
    }
    switch (tkt) {
    case TOK_IDENT: sym = PRD_IDENT; break;
    case TOK_COLON: sym = PRD_COLON; break;
    case TOK_EQUALS: sym = PRD_EQUALS; break;
    case TOK_SEMICOLON: sym = PRD_SEMICOLON; break;
    case TOK_PAR_OPEN: sym = PRD_PAR_OPEN; break;
    case TOK_PAR_CLOSE: sym = PRD_PAR_CLOSE; break;
    case TOK_CUBRACE_OPEN: sym = PRD_CUBRACE_OPEN; break;
    case TOK_CUBRACE_CLOSE: sym = PRD_CUBRACE_CLOSE; break;
    default: sym = PRD_TOKEN; break;
    }
  }
  else {
    sym = INPUT_END;
  }
  
  return prd_parse_impl(stack, sym, g, tkr, st);
}
