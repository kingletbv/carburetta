/* Copyright 2020-2025 Kinglet B.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

int has_suffix(const char *str, const char *suffix) {
  size_t str_len = strlen(str);
  size_t suffix_len = strlen(suffix);
  return (suffix_len <= str_len) && !strcmp(str + str_len - suffix_len, suffix);
}

#define enum_categories \
xx(LU, Lu) \
xx(LL, Ll) \
xx(LT, Lt) \
xx(LM, Lm) \
xx(LO, Lo) \
xx(MN, Mn) \
xx(MC, Mc) \
xx(ME, Me) \
xx(ND, Nd) \
xx(NL, Nl) \
xx(NO, No) \
xx(PC, Pc) \
xx(PD, Pd) \
xx(PS, Ps) \
xx(PE, Pe) \
xx(PI, Pi) \
xx(PF, Pf) \
xx(PO, Po) \
xx(SM, Sm) \
xx(SC, Sc) \
xx(SK, Sk) \
xx(SO, So) \
xx(ZS, Zs) \
xx(ZL, Zl) \
xx(ZP, Zp) \
xx(CC, Cc) \
xx(CF, Cf) \
xx(CS, Cs) \
xx(CO, Co) \
xx(CN, Cn)


enum UnicodeCategories {
  UCCG_INVALID,  /* Invalid unicode codepoint */
#define xx(id, tag) UCCG_##id,
  enum_categories
#undef xx
  UCCG_END
};

const char *cat2id(int cat) {
  switch (cat) {
  case UCCG_INVALID: return "UCCG_INVALID";
#define xx(id, tag) case UCCG_##id: return "UCCG_" #id;
    enum_categories
#undef xx
  }
  assert(0);
  return NULL;
}

int main(int argc, char **argv) {
  static char categories[0x110000] = { 0 };
  size_t n;
  for (n = 0; n < sizeof(categories) / sizeof(*categories); ++n) {
    categories[n] = UCCG_INVALID;
  }
  FILE *ucdfp = fopen("UnicodeData.txt", "rb");
  if (!ucdfp) {
    perror("Failed to open UnicodeData.txt");
    return 1;
  }
#define MAX_LINE_SIZE 300
  char line[MAX_LINE_SIZE + 1 /* guaranteed null terminator space */];
  /* Some docs indicate this is done for us (msdn), some don't discuss it, terminate strings anyway.. */
  line[MAX_LINE_SIZE] = '\0';

  int Lu_Count = 0;
  int prev_codepoint = 0;
  int first_cat = 0;
  int first_codepoint = 0;
  while (fgets(line, MAX_LINE_SIZE, ucdfp)) {
    char *cols[6];
    cols[0] = strchr(line, ';');
    char *p = line;
    int n = 0;
    for (n = 0; n < 6; ++n) {
      cols[n] = p;
      while (*p && (*p != ';')) {
        p++;
      }
      if (*p == ';') {
        *p = 0;
        p++;
      }
    }

    int codepoint = (int)strtol(cols[0], NULL, 16);
    int cat = -1;
#define xx(id, tag) if (!strcmp(#tag, cols[2])) { cat = UCCG_##id; }
    enum_categories
#undef xx
    if (cat == -1) {
      printf("%s -- %s -- %s (%d)\n", cols[0], cols[1], cols[2], cat);
    }
    else {
      assert((codepoint >= 0) && (codepoint < 0x110000));
      categories[codepoint] = cat;
    }
    if (has_suffix(cols[1], "First>")) {
      first_cat = cat;
      first_codepoint = codepoint;
    }
    else if (has_suffix(cols[1], "Last>")) {
      if (cat != first_cat) {
        printf("%s -- %s -- %s (%d)\n", cols[0], cols[1], cols[2], cat);
      }
      int cp;
      /* Fill up to current position */
      for (cp = first_codepoint; cp != codepoint; ++cp) {
        categories[cp] = cat;
      }
    }

    prev_codepoint = codepoint;
  }

  fclose(ucdfp);

  FILE *fph = fopen("unicode_data.h", "wb");
  if (!fph) {
    perror("Could not open unicode_data.h for writing");
    return 1;
  }
  fprintf(fph, "/* generated by gen_unicode_data.c */\n\n");
  fprintf(fph, "#ifndef UNICODE_DATA_H\n"
               "#define UNICODE_DATA_H\n\n"
               "#ifdef __cplusplus\n"
               "extern \"C\" {\n"
               "#endif\n\n");
  fprintf(fph, "enum UnicodeCategory {\n");
  fprintf(fph, "  UCCG_INVALID,  /* Invalid unicode codepoint */\n");
#define xx(id, tag) fprintf(fph, "  UCCG_" #id ",\n");
  enum_categories
#undef xx
  fprintf(fph, "};\n");
  fprintf(fph, "/* index by codepoint/256; value is -1 if the range is described by a more\n"
               "** detailed map, found at unicode_precise_category_map_lookup[codepoint/256].\n"
               "** If all codepoints in the /256 range have the same category, it is listed\n"
               "** in unicode_granular_category_map directly.\n"
               "** If all codepoints in the /256 range have the same category, then\n"
               "** unicode_precise_category_map_lookup[codepoint/256] will be NULL.\n"
               "*/\n");
  fprintf(fph, "extern signed char unicode_granular_category_map[];\n");
  fprintf(fph, "extern signed char *unicode_precise_category_map_lookup[];\n");

  fprintf(fph, "\n#ifdef __cplusplus\n"
               "} /* extern \"C\" */\n"
               "#endif\n\n"
               "#endif /* UNICODE_DATA_H */\n");
  fclose(fph);

  FILE *fpout = fopen("unicode_data.c", "wb");
  if (!fpout) {
    perror("Could not open unicode_data.c for writing");
    return 1;
  }

  int histogram[UCCG_END];
  int codepoint;
  int num_distinct;
  int submaps_needed = 0;
  int map_entries = 0;
  fprintf(fpout, "/* generated by gen_unicode_data.c */\n"); 
  fprintf(fpout, "#include <stdlib.h>\n");
  fprintf(fpout, "#include \"unicode_data.h\"\n\n");
  fprintf(fpout, "signed char unicode_granular_category_map[] = {\n");
  for (codepoint = 0; codepoint <= 0x110000; ++codepoint) {
    if (!(codepoint & 0xFF)) {
      if (codepoint) {
        /* Find number of distinct codepoint maps.. */
        num_distinct = 0;
        int cat = -1;
        for (n = 0; n < UCCG_END; ++n) {
          if (histogram[n]) {
            num_distinct++;
            cat = n;
          }
        }
        assert(num_distinct); /* must have at least 1 */
        if (num_distinct > 1) {
          fprintf(fpout, "  -1, /* %x - %x */ \n", codepoint - 0x100, codepoint - 1);
          submaps_needed++;
        }
        else {
          /* Only 1 category and cat is it */
          fprintf(fpout, "  %s, /* %x - %x */ \n", cat2id(cat), codepoint - 0x100, codepoint - 1);
        }
        map_entries++;
      }
      memset(histogram, 0, sizeof(histogram));
    }
    if (codepoint < 0x110000) {
      histogram[categories[codepoint]]++;
    }
  }
  fprintf(fpout, "}; /* unicode_granular_category_map */\n");

  for (codepoint = 0; codepoint <= 0x110000; ++codepoint) {
    if (!(codepoint & 0xFF)) {
      if (codepoint) {
        /* Find number of distinct codepoint maps.. */
        num_distinct = 0;
        int cat = -1;
        for (n = 0; n < UCCG_END; ++n) {
          if (histogram[n]) {
            num_distinct++;
            cat = n;
          }
        }
        assert(num_distinct); /* must have at least 1 */
        if (num_distinct > 1) {
          /* Write the precise map for this range of codepoints.. */
          int cp;
          fprintf(fpout, "static signed char precise_map_%x_%x[] = {\n", codepoint - 0x100, codepoint - 1);
          for (cp = codepoint - 0x100; cp < codepoint; ++cp) {
            fprintf(fpout, "%s%s", (cp == (codepoint - 0x100)) ? "  " : ", ", cat2id(categories[cp]));
          }
          fprintf(fpout, "\n};\n");
        }
        else {
          /* Only 1 category, has no precise map (skip it) */
        }
      }
      memset(histogram, 0, sizeof(histogram));
    }
    if (codepoint < 0x110000) {
      histogram[categories[codepoint]]++;
    }
  }

  fprintf(fpout, "signed char *unicode_precise_category_map_lookup[] = {\n");
  int precise_map_index = 0;
  for (codepoint = 0; codepoint <= 0x110000; ++codepoint) {
    if (!(codepoint & 0xFF)) {
      if (codepoint) {
        /* Find number of distinct codepoint maps.. */
        num_distinct = 0;
        int cat = -1;
        for (n = 0; n < UCCG_END; ++n) {
          if (histogram[n]) {
            num_distinct++;
            cat = n;
          }
        }
        assert(num_distinct); /* must have at least 1 */
        if (num_distinct > 1) {
          fprintf(fpout, "  precise_map_%x_%x,\n", codepoint - 0x100, codepoint - 1);
        }
        else {
          /* Only 1 category, has no precise map */
          fprintf(fpout, "  NULL, /* %x - %x */\n", codepoint - 0x100, codepoint - 1);
        }
      }
      memset(histogram, 0, sizeof(histogram));
    }
    if (codepoint < 0x110000) {
      histogram[categories[codepoint]]++;
    }
  }
  fprintf(fpout, "}; /* unicode_precise_category_map_lookup */\n");

  fclose(fpout);

  //printf("%d submaps needed (of %d entries total)\n", submaps_needed, map_entries);

  return 0;
}