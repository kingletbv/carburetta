/* Copyright 2020-2024 Kinglet B.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

/* This is the hand-crafted external interface that the C code of the CBRT file will
 * implement. It resides with the other sourcefiles, whereas, upon compilation, this
 * .cbrt's generated .c and .h files may reside in an intermediate directory. Care
 * must be taken that the directory with the sourcefiles is on the include path when
 * compiling carburetta's .c output. */
#include "ini_reader.h"

%scanner%

/* Here we indicate that all top-level symbols generated by carburetta for this file
 * should have either the prefix "iniparser_" - or, for constants, the uppercased version
 * of that prefix "INIPARSER_". In the manual you will see this referred to as "<prefix>"
 * and "<PREFIX>" respectively. */
%prefix iniparser_

/* We want our "ini_reader" structure to be included as an argument to the _scan and _parse
 * functions generated, so we can interact with it. Here we change the prototype of those
 * functions to include an extra argument (ir) which is now available from the actions. */
%params struct ini_reader *ir


: ^ [\ \t]* \[ [\ \t]* [_a-zA-Z][_a-zA-Z0-9]* [\ \t]* \] [\ \t]* $ {
  /* Section header, pattern consists of: */
  /* <Line Start>
   * <Optional Whitespace>
   * <opening [ brace>
   * <optional whitespace>
   * <identifier>
   * <optional whitespace>
   * <closing ] brace>
   * <optional whitespace>
   * <end of line> */

  /* Locate identifier */
  char *p = strchr($text, '[') + 1;

  while (!isalnum(*p) && (*p != '_')) p++;
  
  char *ident = p;
  while (isalnum(*p) || (*p == '_')) p++;
  char *ident_end = p;

  /* Terminate the identifier so we don't return the trailing ']'. You're allowed
   * to directly mess with the matched string like this, provided you take certain
   * limitations to heart (see manual at section $text.) */
  *ident_end = '\0';
    
  /* We may directly return this pointer (ident) to the match buffer, it will 
   * be good until scanning resumes. */
  ir->section_ = ident;
  ir->key_ = NULL;
  ir->value_ = NULL;

  /* We can exit directly out of our action from the _scan() or _parse() generated
   * functions. The designs you produce with Carburetta therefore don't need to
   * rely on callback or ownership of the calling context to work. Code that uses
   * carburetta can remain in control.
   * Upon re-entry to the scan function, code continues after the action that
   * returned. Until the code continues, direct pointers to the match buffer will
   * continue to be valid for external use. */
  return INI_READER_SECTION;
}

: ^ [\ \t]* [_a-zA-Z][_a-zA-Z0-9]* [\ \t]* = .* $ {
  /* Key-value pair, pattern consists of: */
  /* <Line Start>
   * <Optional Whitespace>
   * <Identifier>
   * <Optional Whitespace>
   * <Equals =>
   * <Everything goes until end of line, excluding the newline.>
   */
  char *p = $text;

  /* Locate identifier */
  while (!isalnum(*p) && (*p != '_')) p++;

  char *key = p;
  while (isalnum(*p) || (*p == '_')) p++;
  char *key_end = p;

  /* Move on up to the value; the value is everything *after* the 
   * first '=' to the end of the line (excluding the '\n' which hasn't
   * been matched by $.) */
  while (*p++ != '=');

  char *value = p;
  size_t value_length = ($text + $len) - value;

  /* Terminate the identifier by modifying the string directly in the match
   * buffer. We're allowed to do this, it is why $text is a char* and not
   * a const char *. See the $text manual entry for more details and limitations. */
  *key_end = '\0';

  /* Section is not available, but may still be pointing into a match buffer with
   * entirely different contents. Clear it out. */
  ir->section_ = NULL;

  /* Set key and value. These pointers are directly into the match buffer, which
   * is permissable (see discussion at the section action above and the $text entry
   * of the manual.) */
  ir->key_ = key;
  ir->value_ = value;

  return INI_READER_KEY_VALUE;
}

/* Newline (ignored) */
: \n;

/* Empty line (ignored) */
: ^ [\ \t]* $;

/* Comment line (ignored) */
: ^ [\ \t]* \; .* $;

%%

void ini_reader_init(struct ini_reader *ir) {
  /* <prefix>_stack_init() is guaranteed to not fail, and will actually put off some
   * of its initialization (e.g. allocations) until actual scanning starts to ensure
   * this is the case. Consequently, you can create your own objects to 
   * initialize without failure if that is something you need. */
  iniparser_stack_init(&ir->stack_);
  ir->section_ = NULL;
  ir->key_ = NULL;
  ir->value_ = NULL;
}

void ini_reader_cleanup(struct ini_reader *ir) {
  /* <prefix>_stack_cleanup() will free all memory, and call deconstructors for any
   * of the datatypes of symbols that are currently "in flight" inside the scanner and
   * parser driver code. In this example we don't have any symbols nor associated data
   * so <prefix>_stack_cleanup() just frees the buffers used. */
  iniparser_stack_cleanup(&ir->stack_);
}

int ini_reader_read(struct ini_reader *ir, FILE *fp) {
  for (;;) {
    int r = iniparser_scan(&ir->stack_, ir);
    if (r == _INIPARSER_FEED_ME) {
      /* Read more data - we're being a bit cheeky here with this example and using
       * a globally allocated buffer, so don't expect this to work in multi-threaded
       * production scenarios */
      static char buf[500];
      size_t bufsize;
      if (fp == stdin) {
        /* Assume interactive input and use fgets; apply trick so we can distinguish between the
         * end of the input string and '\0' characters from raw data. */
        /* Ensure there are no '\0''s in the buf prior to reading */
        memset(buf, '\x1', sizeof(buf));
        if (!fgets(buf, sizeof(buf), fp)) {
          bufsize = 0;
        }
        else {
          /* The last '\0' we find was added by fgets as null terminator */
          char *last_null_terminator = buf + sizeof(buf) - 1;
          char *p = last_null_terminator;
          while ((p > buf) && (*p != '\0')) {
            p--;
          }
          bufsize = (size_t)(p - buf);
        }
      }
      else {
        bufsize = fread(buf, 1, sizeof(buf), fp);
      }
      if (!bufsize) {
        if (ferror(fp)) {
          return INI_READER_IO_ERROR;
        }
      }
      /* We've done the IO bit that can fail above, now pass this buffer into the <prefix>set_input().
      * function. It will maintain a reference to the buffer, we should not touch it until the next
      * time _INIPARSER_FEED_ME is returned or we cleanup the parser. */
      iniparser_set_input(&ir->stack_, buf, bufsize, feof(fp));
    }
    else {
      return r;
    }
  }
}

