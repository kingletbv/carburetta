/* Copyright 2020-2024 Kinglet B.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <stdlib.h>

#include "ini_reader.h"

int main(int argc, char **argv) {
  FILE *inputfp = stdin;
  const char *inputfile = NULL;

  /* Find input file amongst the arguments. */
  int n;
  for (n = 1; n < argc; ++n) {
    if ((argv[n][0] == '-') && (argv[n][1] == '-')) {
      /* Skip value for the argument */
      if ((n + 1) < argc) n++;
      continue;
    }
    /* Not an -- style argument, use it as input file */
    inputfile = argv[n];
    inputfp = fopen(argv[n], "rb");
    if (!inputfp) {
      fprintf(stderr, "Failed to open input file \"%s\"\n", argv[n]);
      return EXIT_FAILURE;
    }
  }

  struct ini_reader ir;
  ini_reader_init(&ir);

  int done = 0;
  int failed = 0;
  while (!done) {
    switch (ini_reader_read(&ir, inputfp)) {
      /* Handle the error conditions first... */
      case _INIPARSER_LEXICAL_ERROR:
        fprintf(stderr, "Line %d, column %d: Lexical error\n", iniparser_line(&ir.stack_), iniparser_column(&ir.stack_));
        done = 1;
        failed = 1;
        break;
      case _INIPARSER_INTERNAL_ERROR:
        fprintf(stderr, "Line %d, column %d: Internal error\n", iniparser_line(&ir.stack_), iniparser_column(&ir.stack_));
        done = 1;
        failed = 1;
        break;
      case _INIPARSER_NO_MEMORY:
        /* No memory, malloc() returned NULL. May retry if there is some way to free up memory first; here there is not. */
        fprintf(stderr, "Line %d, column %d: No memory\n", iniparser_line(&ir.stack_), iniparser_column(&ir.stack_));
        done = 1;
        failed = 1;
        break;
      case _INIPARSER_OVERFLOW:
        /* Overflow, very unlikely to occur but when it does it typically suggests corruption like stray pointers and the like. */
        fprintf(stderr, "Line %d, column %d: Overflow\n", iniparser_line(&ir.stack_), iniparser_column(&ir.stack_));
        done = 1;
        failed = 1;
        break;
      case INI_READER_IO_ERROR:
        /* We defined this errorcode ourselves, it is not generated by Carburetta (as Carburetta generated code will not do the
         * actual IO itself.) */
        fprintf(stderr, "I/O error trying to read from %s", inputfile ? inputfile : "stdin");
        done = 1;
        failed = 1;
        break;

      /* Now for the business as usual conditions. */
        
      /* Success conditions */
      case INI_READER_SECTION:
        fprintf(stdout, "Section: \"%s\" found\n", ir.section_);
        break;
      case INI_READER_KEY_VALUE:
        fprintf(stdout, "Key: \"%s\" Value: \"%s\"\n", ir.key_, ir.value_);
        break;

      case _INIPARSER_FINISH:
        /* Good result */
        done = 1;
        failed = 0;
        break;
    }
  }

  ini_reader_cleanup(&ir);

  fclose(inputfp);

  return failed ? EXIT_FAILURE : EXIT_SUCCESS;

}
